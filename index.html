<!DOCTYPE html>

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>Learner's Bucket</title>
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="">
</head>

<body>
    <!-- Var, Let and Const in JavaScript -->
    <h2>Var, Let and Const in JavaScript</h2>
    <!-- Var in javascript -->
    <p>• Var in javascript are function scoped, which means they are accessible outside the block scope
        even though we have declared them inside it.</p>
    <!-- Hoisting -->
    <p>• This happends because of Hoisting.</p>
    <p>var are treated as if they are at the top of the function (or global scope) regardless of where
        the actual declaration occurs, this is called hoisting.</p>
    <!-- Let in javascript -->
    <p>• Let are declared same as var but it limits the variable scope to the given block. That is why
        we should declare at the top of the block so that is accessible throughout the block and its
        sub-blocks.</p>
    <!-- Const in javascript -->
    <p>• Like let const is also block scoped. But it differs from the fact that their variable cannot
        be redeclared or change by re-assigning the value. The value remains Constant.</p>
    <hr>

    <!-- What is Temporal Dead Zone ? -->
    <h2>What is Temporal Dead Zone?</h2>
    <p>• Temporal Dead Zone is the time since when the let variable was hoisted and till it is intialized some
        value,
        the time between that is known as the Temporal Dead Zone.</p>
    <p>• So whenever you try to access a variable inside the temporal dead zone, it gives you a ReferenceError.</p>
    <p>• When the variable is inside this temporal dead zone you cannot access them and they can only be accessed
        once
        some value is initialized to them.</p>
    <p>• The let and const variables are not accessible before they are initialized with some value, and the phase
        between the starting of the execution of block in which the let or const variable is declared till that
        variable
        is being initialized is called Temporal Dead Zone for the variable.</p>
    <hr>

    <!-- Transpiler -->
    <h2>Transpiler</h2>
    <p>• If you want old or older versions of browsers to understand new features, one must use a
        transpiler.</p>
    <p>• A transpiler converts the new JavaScript code to a browser compatible javascript.</p>
    <p>• That is why babel is created.</p>
    <p>• Babel is a JavaScript compiler which converts the new Javascript to a browser compatible
        Javascript.</p>
    <hr>

    <!-- How to use Babel? -->
    <h2>How to use Babel?</h2>
    <p>• Copy the Babel cdn from babel cdn website and import this in your website.</p>
    <p>• Now after importing the cdn, we need to tell the browser that the current script which we
        are writing is in Babel.</p>
    <p>• We can do that by setting the type of the script tag.</p>
    <!-- <script type = "text/babel">
            let n = [1, 2, 3];
            let squares = n.map((e) => e * e);
        </script> -->
    <hr>

    <!-- What is the difference between Polyfilling and Transpiling? -->
    <h2>What is the difference between Polyfilling and Transpiling?</h2>
    <p>• A polyfill tries to emulate specific methods, so you can use them as if they were already
        supported by the browser (or node engine), on the other hand, A transpiler will modify your
        code and replace code by other code that does the same, which can then be executed in old
        browsers.</p>
    <p>• So you can use a polyfill if your target browser did not implement the feature you need
        to use. A transpiler, on the other hand, is more complex and will let you use the new
        language syntax and transforming your source code.</p>
    <p>• In short, a polyfill will change the code in your target browser if some of the new features
        you wanted to add are not working.</p>
    <p>• And transpiler will let us use the new code of the new features which we wanted to add,
        but will transform or convert it into the new source code first.</p>
    <hr>

    <!-- What are Template Strings -->
    <h2>What are Template Strings</h2>
    <p>• Template Literals are strings which allow embedded expressions. Before ES6 introduced them, they were
        called as Template Strings.</p>
    <p>• JavaScript strings always had limitations compared to the strings of the other programming languages. Apart
        from simple concatenation, there was not much we could have done with strings.</p>
    <p>• ECMAScript 6's template literals provided syntax for creating domain-specific languages (DSLs) for working
        with
        content in a safer way than the solutions available earlier.</p>
    <p>• With template strings we can handle following features easily : <br>
        -- Multiline Strings <br>
        -- Basic string formatting <br>
        -- HTML Escaping </p>
    <p>• Against the standard ' ' and " " quotes template literals uses back-ticks ` `.</p>
    <hr>

    <!-- JavaScript Fat Arrow Function -->
    <h2>JavaScript Fat Arrow Function</h2>
    <p>• One of the most interesting parts of ES6 is arrow functions. Arrow functions as it sounds is the new syntax =>
        of declaring a function. But it behaves differently from the traditional functions of JavaScript.</p>
    <p>-- No this, arguments, super or new.target bindings of its own. <br>
        -- We cannot use them as Constructors. <br>
        -- They do not have prototype property. <br>
        -- yield keyword cannot be used (Until in special cases). <br>
        -- Unique named parameters.</p>
    <p>• When to avoid using arrow functions in JavaScript : <br>
        -- If we want to access the this of the current function then it is better to avoid the arrow functions. <br>
        -- Also if you want to access all the arguments of the function then it is better to avoid arrow functions as
        arguments are missing or use rest operators.</p>
    <hr>

    <!-- Functions with default parameters in JavaScript -->
    <h2>Functions with default parameters in JavaScript</h2>
    <p>• Functions are really amazing in javascript as they allow to pass any numbers of parameters regardless of the
        numbers of parameters declared. Thus there is a need to handle function with default parameters.</p>
    <p>• Before exploring the default parameters of ES6, let us see how to handle it in older versions of javascript :
    </p>
    <p>•<strong> Before ES6 :</strong> <br>
        -- In javascript the function parameters were default to undefined. To handle them we had to check the
        parameters and assign values if they were undefined. <br>
        -- If we have not checked and assigned the value for by then it would have returned NaN. <br>
        -- While this approach is good but imagine we have more parameters and we have to check for every parameters and
        assign value to it. It will get quite lengthy. </p>
    <p>•<strong> After ES6 :</strong> <br>
        -- With default parameters introduction in ES6 we can now assign the default values in the function head itself.
        <br>
        -- The default value is assigned only to the undefined parameters not to the other falsy values.</p>
    <p>•<strong> Passing Functions, Arrays and Objects : </strong> <br>
        -- We could also set default parameters to be function, arrays and objects in javascript. <br>
        -- We can also set the existing parameters as the default value. <br>
        -- Default values are evaluated at call time. <br> </p>
    <p>•<strong> Destructured values with default parameters :</strong> <br>
        -- We can set the default parameters with destructuring. <br>
        -- We will use arrow (=>) function for it.</p>
    <hr>

    <!-- ES6 Object Literals -->
    <h2>ES6 Object Literals</h2>
    <p>• Applications in javascript are getting more complex with time and use lots of objects, which makes sense as
        almost everything in javascript are some types of objects.</p>
    <p>• With more objects, comes necessity to use them more efficiently and ES6 focuses heavily on improving them.</p>
    <p>• JavaScript has different types of objects used in standard as well as in the execution environment added by the
        browsers or Nodejs.</p>
    <p>• The succinct syntax of object literals for creating objects in javascript has made it so popular that JSON
        adopted the same syntax. ES6 make object literals more powerful and more succinct by extending the syntax.</p>

    <!-- Deconstructing variables into keys and values -->
    • <strong>Deconstructing variables into keys and values</strong>
    <p>-- <u>Before ES6</u> :
        <br> Creating an object literal in javascript.
        <br>
        <br> var name = 'Prashant Yadav';
        <br> var age = 23;
        <br> var nationality = 'Indian';
        <br> var designation = 'Software Engineer';
        <br>
        <br> var user = {
        <br> name : name,
        <br> age : age,
        <br> nationality : nationality,
        <br> designation : designation
        <br> }
        <br>
        <br> console.log(user);
        <br> // {name : 'Prashant Yadav', age : 23, nationality : 'Indian', designation : 'Software Engineer'}
    </p>
    <p>-- <u>After ES6</u> :
        <br> Creating an object literal in ES6.
        <br>
        <br> var name = 'Prashant Yadav';
        <br> var age = 23;
        <br> var nationality = 'Indian';
        <br> var designation = 'Software Engineer';
        <br>
        <br> var user = {
        <br> name,
        <br> age,
        <br> nationality,
        <br> designation
        <br> }
        <br>
        <br> console.log(user);
        <br> // {name : 'Prashant Yadav', age : 23, nationality : 'Indian', designation : 'Software Engineer'}
    </p>
    <p>-- If variable name is same as the property name then we can skip assigning the value to the property and use the
        above syntax to declare objects.</p>

    <!-- Declaring functions inside objects -->
    • <strong>Declaring functions inside objects</strong>
    <p>-- <u>Before ES6</u> :
        <br>
        <br> var name = 'Prashant Yadav';
        <br> var age = 23;
        <br> var nationality = 'Indian';
        <br> var designation = 'Software Engineer';
        <br>
        <br> var user = {
        <br> name : name,
        <br> age : age,
        <br> nationality : nationality,
        <br> designation : designation,
        <br> detail : function () {
        <br> return this.name + ' is an ' + this.nationality + ' working as ' + this.designation;
        <br> }}
        <br>
        <br>console.log(user.detail());
        <br> // Prashant Yadav is an Indian working as Software Engineer
    </p>
    <p>-- <u>After ES6</u> :
        <br>
        <br> var name = 'Prashant Yadav';
        <br> var age = 23;
        <br> var nationality = 'Indian';
        <br> var designation = 'Software Engineer';
        <br>
        <br> var user = {
        <br> name,
        <br> age,
        <br> nationality,
        <br> designation
        <br> detail() {
        <br> return this.name + ' is an ' + this.nationality + ' working as ' + this.designation;
        <br> }}
        <br>
        <br> console.log(user);
        <br> // {name : 'Prashant Yadav', age : 23, nationality : 'Indian', designation : 'Software Engineer'}
    </p>
    <p>-- We no longer need to declare function keyword, we can declare the function directly with above syntax.</p>

    <!-- We can also declare the => fat arrow function -->
    • <strong>We can also declare the => fat arrow function</strong>
    <p>const math = {
        <br> add : (a, b) => a + b,
        <br> mul : (a, b) => a * b,
        <br> sub : (a, b) => a-b,
        <br> div : (a, b) => a / b,
        <br> }
        <br>
        <br> console.log(math.add(1, 1)); // 2
        <br> console.log(math.mul(1, 1)); // 1
        <br> console.log(math.sub(1, 1)); // 0
        <br> console.log(math.div(1, 1)); // 1
    </p>

    <!-- Dynamically define properties of an object -->
    • <strong>Dynamically define properties of an object</strong>
    <p>-- <u>Before ES6</u> :
        <br>
        <br> To dynamically define properties of the object in ES5 or earlier we used to first create the object and
        then modify it.
        <br>
        <br> var name = 'name';
        <br> // create empty object
        <br>
        <br> var user = {}
        <br> // update the object
        <br>
        <br> var [name] = 'Prashant Yadav';
        <br>
        <br> console.log(user.name);
        <br> // Prashant Yadav
    </p>
    <p>-- <u>After ES6</u> :
        <br>
        <br> With ES6 we can do both the things same time. Computed property names are part of the object literal
        syntax.
        <br>
        <br> var name = 'first';
        <br>
        <br> var suffix = 'name';
        <br> // create empty object and assigning the value
        <br>
        <br> var user = {
        <br> [name] : 'Prashant',
        <br> ['last ' + suffix] : 'Yadav'
        <br> }
        <br>
        <br> console.log(user.first + ' ' + user['last name']);
        <br> // Prashant Yadav
    </p>

    <!-- Declaring duplicate properties -->
    • <strong>Declaring duplicate properties</strong>
    <p>-- <u>Before ES6</u> :
        <br>
        <br> In ES5 and earlier declaring duplicate property names inside object literals in strict mode would throw
        error.
        <br>
        <br>'use strict';
        <br> var user = {
        <br> name : 'prashant',
        <br> name : 'golu'
        <br> }
        <br>
        <br> // syntax error
    </p>
    <p>-- <u>After ES6</u> :
        <br>
        <br> In ES6 we can declare duplicate property names inside object literals in strict as well as nonstrict
        mode. It will just overwrite the existing value.
        <br>
        <br>'use strict';
        <br> var user = {
        <br> name : 'prashant',
        <br> name : 'golu'
        <br> }
        <br>
        <br> console.log(user.name);
        <br> // golu
    </p>
    <hr>

    <!-- JavaScript Set -->
    <h2>JavaScript Set</h2>
    <p>• Before ES6 there was only one data-structure, Array which we could have used for numeric operations and for
        other non-numeric operations we had to use Objects.</p>
    <p>• Arrays came with extra methods which we could use to create stack and queue.</p>
    <p>• With the introduction of javascript Set and Map, we now have some extra data-structures in javascript's
        library.</p>
    <p>• Sets are the unique collection of values of any type, which also includes NaN and undefined.</p>

    <!-- Before ES6 -->
    <p>-- <u>Before ES6</u> :
        <br>
        <br> Before sets introduction in ES6 there was workaround which developers used to have to create sets but
        there was limitation to that workaround. Let us see that first to exactly know why there was need for it.
        <br>
        <br> var set = {};
        <br> if (!set.foo) {
        <br> set.foo = true;
        <br> }
    </p>
    <p>-- We have created an empty object and assigned true to the properties so that we can check if that value is
        present.</p>
    <p>-- This works well in the simple scenarios but when we have to use more complex situations we run into the
        limitations of the object properties.</p>
    <p>var set = {};
        <br> var key = {};
        <br> set[25] = 'prashant';
        <br> set[key] = 5;
        <br>
        <br> console.log(set['25']); // prashant
        </br> console.log(set[key]); // 5
    </p>
    <p>-- Here the object internally converts the numeric 25 and key to string '25' because object parameters must be
        string, Thus we cannot use both of them simultaneously.</p>

    <!-- After ES6 -->
    <p>-- <u>After ES6</u> :
        <br>
        <br> With introduction of Set and WeakSet in ES6 we don't have to worry about the workaround limitations.
        <br>let set = new Set([!iterable]);
        <br> if an iterable object like Array is passed then all its items will be added to the set.
        <br>
        <br> let set = new Set();
        <br> set.add(25);
        <br> set.add('25');
        <br>
        <br> let set2 = new Set([1, 2, 3, 4, 5, 6, 7, 8]);
        <br> let set3 = new Set('Prashant');
        <br>
        <br> console.log(set.size); // 2
        <br> console.log(set2.size); // 8
        <br> console.log(set3.size); // 7 ['P', 'r', 'a', 's', 'h', 'n', 't'];
    </p>
    <p>-- Sets do not convert the values while checking (Except for +0 and -0).</p>
    <p>let set = new Set();
        <br> let key = {};
        <br> let key2 = {};
        <br> set.add(key);
        <br> set.add(key2);
        <br>
        <br> console.log(set.size) // 2
    </p>

    <!-- Sets Properties -->
    • <strong>Sets Properties</strong>
    <p>-- Set.prototype.constructor <br>
        -- Set.prototype.size
    </p>

    <!-- Sets Methods -->
    • <strong>Sets Methods</strong>
    <p>-- Set.prototype.add(item)
        <br> -- Set.prototype.clear()
        <br> -- Set.prototype.delete(item)
        <br> -- Set.prototype.entries()
        <br> -- Set.prototype.foreach(callback, thisArg)
        <br> -- Set.prototype.has(item)
        <br> -- Set.prototype[@@iterator]()
        <br> -- Set.prototype.keys()
        <br> -- Set.prototype.values()
    </p>

    <!-- Iterating with javascript Set -->
    • <strong>Iterating with javascript Set</strong>
    <p>-- <u>Simple Iteration</u>
        <br>
        <br> let set = new Set();
        <br> set.add(1);
        <br> set.add(2);
        <br> set.add(3);
        <br> set.add(4);
        <br>
        <br> // foreach loop
        <br> set.forEach((e) => {console.log(e);});
        <br> // 1
        <br> // 2
        <br> // 3
        <br> // 4
        <br>
        <br> for of loop
        <br> for (let item of set) {console.log(item);}
        <br> // 1
        <br> // 2
        <br> // 3
        <br> // 4
    </p>

    <!-- Iterating objects of Set -->
    <p>-- <u>Iterating objects of Set</u>
        <br>
        <br> let set = new Set();
        <br> set.add(1);
        <br> set.add('prashant');
        <br> set.add({a: 1, b: 2, c:3, d:4});
        <br>
        <br> for (let item of set.keys()) {
        <br> console.log(item);
        <br> }
        <br> // 1
        <br> // prashant
        <br> // {a: 1, b: 2, c: 3, d: 4}
        <br>
        <br> for (let item of set.values()) {
        <br> console.log(item);
        <br> }
        <br> // 1
        <br> // prashant
        <br> // {a:1, b:2, c:3, d:4}
        <br>
        <br> for (let [key, value] of set.entries()) {
        <br> console.log(key, value);
        <br> }
        <br> // 1 1
        <br> // prashant prashant
        <br> // {a:1, b:2, c:3, d:4} {a:1, b:2, c:3, d:4}
        <br>
        <br> let set = new Set();
        <br> set.add(1);
        <br> set.add('prashant');
        <br> set.add({a:1, b:2, c:3, d:4});
        <br>
        <br> // using `.next()`
        <br>const iterator = set.values();
        <br>
        <br> console.log(iterator.next().value);
        <br> // 1
        <br>
        <br> console.log(iterator.next().value);
        <br> // prashant
        <br>
        <br> console.log(iterator.next().value);
        <br> // {a:1, b:2, c:3, d:4}
    </p>
    <hr>

    <!-- WeakSets -->
    <h2>WeakSets</h2>
    <p>• A WeakSet is same as the Set except it can only store objects.</p>
    <p>let user = {name: 'Prashant Yadav', age: 23};
        <br>const users = new WeakSet(user);
    </p>
    <hr>

    <!-- Difference between Sets and WeakSets -->
    <h2>Difference between Sets and WeakSets</h2>
    <p>• WeakSets can only store objects unlike the Sets.</p>
    <p>• The add() method throws error when non-object item is passed to the WeakSet.</p>
    <p>• The has() and delete() method returns false for non-object.</p>
    <p>• WeakSets are not Iterable.</p>
    <p>• They do not have size and foreach as well.</p>
    <p> let user = {name: 'Prashant Yadav', age: 23};
        <br> let user2 = {name: 'Prashant Yadav', age: 23};
        <br> let user3 = {name: 'Prashant Yadav', age: 23};
        <br>
        <br> const users = new WeakSet();
        <br> users.add(user);
        <br> users.add(user2);
        <br> users.add(user3);
        <br>
        <br> console.log(users.has(user2)); // true
        <br>
        <br> users.delete(user2);
        <br>
        <br> console.log(users.has(user2)); // false
    </p>
    <p>• The WeakSet cleans itself once the object is deleted or if there is no reference to the object.</p>
    <p> console.log(users);
        <br> user3 = null;
        <br> console.log(users);
        <br> // WeakSet {{...}, {...}}
        <br>
        <br> // Wait for few seconds
        <br> console.log(users);
        <br> // WeakSet {{...}}
        <br> // it automatically garbage collect the object.
    </p>
    <hr>

    <!-- JavaScript Map -->
    <h2>JavaScript Map</h2>
    <p>• Before ES6 in order to store the key value pair we had to use objects. We never had any extra data structure
        except for an array.</p>
    <p>• With the introduction of JavaScript Map and Set, we have somethig extra to handle the data.</p>
    <p>• Just like Sets, Maps are also used to store the unique values except here it is key value pair.</p>

    <!-- Before ES6 -->
    <p>• <u><strong>Before ES6</strong></u>
        <br> -- Prior to the introduction of javascript Map, developers used to have a workaround to handle the key
        value pair but there was limitations to that workaround. Let us see the workaround first to see why there was
        need for the Maps :
        <br>
        <br> var map = {};
        <br> map.foo = "bar";
        <br>
        <br> // retrieving a value
        <br> let value = map.foo;
        <br> console.log(value);
    </p>
    <p>-- This approach works fine but if the situation gets more complex, then we run into the limitations of the
        object properties.
        <br>
        <br> var map = {};
        <br> map[5] = "bar";
        <br> console.log(map["5"]);
    </p>
    <p>-- Object internally converts anything to string to store the values. So the numeric 5 is converted to "5". Thus
        we cannot use numeric key. The same happends when we use objects as the key.
        <br>
        <br> var map = {};
        <br> var key = {};
        <br> var key2 = {};
        <br> map[key] = "prashant";
        <br> console.log(map[key2]); // prashant
    </p>
    <p>-- It converts object to string.</p>
    <p>-- Maps with falsy key were also difficult to handle.
        <br>
        <br> var map = {};
        <br> map.foo = false;
        <br> // checking for the existence of "foo" or a nonzero value?
        <br> if (map.foo) {
        // ...
        }
    </p>
    <p>-- Here we want to check if value is present inside the key foo but the falsy is automatically converted to the
        false. <strong>Note :</strong> we could use in operator, but that still check in the prototype of the objects,
        which make it only safe to use when an object has a null prototype.</p>

    <!-- After ES6 -->
    <p>• <u><strong>After ES6</strong></u>
        <br> -- Maps are ordered list of key value pair when key as well as value can be of any type.
        <br>
        <br> let map = new Map([iterable]);
        <br>
        <br> -- If an iterable object like Array (arrays with two elements, eg. [[1, 'one'],[2, 'two']]) whose
        elements
        are key-value pairs is passed then all its items will be added to the Map.
        <br> -- null values are treated as undefined.
        <br>
        <br> let map = new Map();
        <br> map.set(5, 'prashant');
        <br> map.set('5', 'yadav');
        <br> console.log(map.size); // 2
        <br> console.log(map.get(5)); // 'prashant'
        <br> console.log(map.get('5')); // 'yadav'
        <br>
        <br> let map2 = new Map([["name", "prashant"], ["age",, 23]]);
        <br> console.log(map2.size); // 2
        <br> console.log(map2.get('name')); // prashant
        <br>
        <br> -- we can also use objects as the key.
        <br>
        <br> let map = new Map();
        <br> let key1 = {};
        <br> let key2 = {};
        <br> map.set(key1, 'prashant');
        <br> map.set(key2, 'yadav');
        <br> console.log(map.size); // 2
        <br> console.log(map.get(key1)); // 'prashant'
        <br> console.log(map.get(key2)); // 'yadav'
    </p>

    <!-- Map Properties -->
    <p>• <strong>Map Properties</strong></p>
    <p> -- Map.prototype.constructor
        <br> -- Map.prototype.size
    </p>

    <!-- Map Methods -->
    <p>• <strong>Map Methods</strong></p>
    <p> -- Map.prototype.set(key, value)
        <br> -- Map.prototype.clear()
        <br> -- Map.prototype.delete(key)
        <br> -- Map.prototype.entries()
        <br> -- Map.prototype.foreach(callback, thisArg)
        <br> -- Map.prototype.has(key)
        <br> -- Map.prototype.get(key)
        <br> -- Map.prototype.[@@iterator]()
        <br> -- Map.prototype.keys()
        <br> -- Map.prototype.delete(key)
        <br> -- Map.prototype.values()
    </p>

    <!-- Adding item to the javascript map -->
    <p>• <strong>Adding item to the javascript map</strong></p>
    <p>let map = new Map();
        <br> map.set(1, 'prashant');
        <br> map.set(2, 'anil');
        <br> map.set(3, 'taha');
        <br> map.set(4, 'ankit');
        <br> map.set(4, 'ankit'); // ignore the duplicate values
        <br> map.set('4', 'yadav');
        <br> map.set('fullname', 'My name is Prashant Yadav');
        <br> map.set(undefined, 20);
        <br> let key = {a : 0, b : 1};
        <br> map.set(key, '25');
        <br> let key2 = function() {};
        <br> map.set(key2, 27);
        <br> map.set(null, 23);
        <br> console.log(map.size); // 9
        <br> console.log(map);
        <br>
        <br> // Map(9) {1 => "prashant", 2 => "anil", 3 => "taha", 4 => "ankit", "4" => "yadav", …}
        <br> // size: (...)
        <br> // __proto__: Map
        <br> // [[Entries]]: Array(9)
        <br> // 0: {1 => "prashant"}
        <br> // 1: {2 => "anil"}
        <br> // 2: {3 => "taha"}
        <br> // 3: {4 => "ankit"}
        <br> // 4: {"4" => "yadav"}
        <br> // 5: {"fullname" => "My name is Prashant Yadav"}
        <br> // 6: {undefined => 20}
        <br> // 7: {Object => 25}
        <br> // 8: {null => 23}
        <br> // length: 9
    </p>

    <!-- Finding item in Map -->
    <p>• <strong>Finding item in Map</strong></p>
    <p>console.log(map.has(key)); // true
        <br> console.log(map.has(null)); // true
        <br> console.log(map.has(key2)); // true
        <br> console.log(map.has(0)); // false
        <br>
        <br> -- Always pass objects as keys by storing it in variables
        <br>
        <br> let key = {a:0, b: 1};
    </p>

    <!-- Getting the value of a given key -->
    <p>• <strong>Getting the value of a given key</strong></p>
    <p> console.log(map.get(key)); // 25
        <br> console.log(map.get(null)); // 23
        <br> console.log(map.get(0)); // undefined
    </p>

    <!-- Removing an item with the given key from the Map -->
    <p>• <strong>Removing an item with the given key from the Map</strong></p>
    <p> map.delete(key);
        <br> map.delete(null);
        <br>
        <br> console.log(map.has(key)); // false
        <br> console.log(map.has(null)); // false
    </p>

    <!-- Iterating with Maps -->
    <p>• <strong>Iterating with Maps</strong></p>
    <p> -- <u>Simple Iteration</u>
        <br> map.forEach((value, key, ownerMap) => {
        <br> console.log(key + " " + value);
        <br> console.log(ownerMap === map);
        <br> });
        <br>
        <br> // 1 prashant
        <br> // true
        <br>
        <br> // 2 anil
        <br> // true
        <br>
        <br> // 3 taha
        <br> // true
        <br>
        <br> // 4 ankit
        <br> // true
        <br>
        <br> // 4 yadav
        <br> // true
        <br>
        <br> // fullname My name is Prashant Yadav
        <br> // true
        <br>
        <br> // undefined 20
        <br> // true
        <br>
        <br> // [object Object] 25
        <br> // true
        <br>
        <br> // null 23
        <br> // true
        <br>
        <br> -- We have used => arrow function, ownerMap is passed as this which equals to the current object ownerMap
        === map that is why it is returning true.
    </p>

    <!-- Using for of loop -->
    <p>• <strong>Using for of loop</strong></p>
    <p> for(const [key, val] of map) {
        <br> console.log(key, val);
        <br> }
        <br>
        <br> // 1 "prashant"
        <br> // 2 "anil"
        <br> // 3 "taha"
        <br> // 4 "ankit"
        <br> // 4 yadav
        <br> // fullname My name is Prashant Yadav
        <br> // undefined 20
        <br> // {a : 0, b : 1} 25
        <br> // f () {} 27
        <br> // null 23
    </p>

    <!-- Using Map.prototype.keys() -->
    <p>• <strong>Using Map.prototype.keys()</strong></p>
    <p> for (var key of map.keys()) {
        <br> console.log(key);
        <br> }
        <br>
        <br> // 1
        <br> // 2
        <br> // 3
        <br> // 4
        <br> // '4'
        <br> // fullname
        <br> // undefined
        <br> // {a:0, b:1}
        <br> // f () {}
        <br> // null
    </p>

    <!-- Using Map.prototype.values() -->
    <p>• <strong>Using Map.prototype.values()</strong></p>
    <p> for (var key of map.values()) {
        <br> console.log(key);
        <br> }
        <br>
        <br> // prashant
        <br> // anil
        <br> // taha
        <br> // ankit
        <br> // yadav
        <br> // My name is Prashant Yadav
        <br> // 20
        <br> // 25
        <br> // 27
        <br> // 23
    </p>

    <!-- Using Map.prototype.entries() -->
    <p>• <strong>Using Map.prototype.entries()</strong></p>
    <p>-- We can destructure the value to access them separately.
        <br>
        <br> for (let[key,value] of map.entries()) {
        <br> console.log(key + " = " + value);
        <br> }
        <br>
        <br> // 1 = prashant
        <br> // 2 = anil
        <br> // 3 = taha
        <br> // 4 = ankit
        <br> // 4 = yadav
        <br> // fullname = My name is Prashant Yadav
        <br> // undefined = 20
        <br> // [object Object] = 25
        <br> // function() {} = 27
        <br> // null = 23
    </p>
    <hr>

    <!-- WeakMaps -->
    <h2>WeakMaps</h2>
    <p>• WeakMaps are to the maps what weakSets are to the sets. In weakMap every key must be object, inserting an
        non-object will result in error. Objects are held weakly so that if there is no reference to key then that value
        will be removed from the WeakMap or garbage collected.</p>
    <p>• Note : key should be objects, but value can be anything.</p>
    <p>• let key = {}, key2 = {};
        <br> let weakMap = new WeakMap([[key1, "prashant"],[key2, 23]]);
        <br> console.log(weakMap.has(key1)); // true
        <br> console.log(weakMap.get(key1)); // "prashant"
        <br> console.log(weakMap.has(key2)); // true
        <br> console.log(weakMap.get(key2)); // 23
    </p>
    <p>• The WeakMap cleans itself once the key is deleted or if there is no reference to the key.</p>
    <p> let dad = {name : "Daddy"};
        <br> let mom = {name : "Mommy"};
        <br>
        <br> let map = new Map();
        <br> let weakMap = new weakMap();
        <br>
        <br> map.set(dad, 1);
        <br> map.set(mom, 2);
        <br>
        <br> dad = null;
        <br> mom = null;
        <br>
        <br> map;
        <br> // map(1) {{...}}
        <br>
        <br> weakMap;
        <br> // Wait for few seconds
        <br> // WeakMap {}
        <br>
        <br> -- As we can see mom was garbade collected when we set its value to null while dad is still present.
    </p>
    <hr>

    <!-- Difference between Maps and WeakMaps -->
    <h2>Difference between Maps and WeakMaps</h2>
    <p>• Passing non-objects as key will result in error.</p>
    <p>• The has(key) and delete(key) method returns false for non-object.</p>
    <p>• They have only four methods has(key), delete(key), get(key), set(key, value).</p>
    <p>• WeakMaps are not iterable.</p>
    <p>• WeakMaps are very useful when creating objects related to particular DOM elements. That way when DOM element is
        no longer associated then it will automatically be garbage collected.</p>
    <hr>

    <!-- JavaScript Spread and Rest Operator -->
    <h2>JavaScript Spread and Rest Operator</h2>
    <p>• The ... is the spread syntax that allows you to specify an array that should be split and have its items passed
        in as seperate arguments to a function.</p>
    <p>• According to MDN - The spread syntax allows an iterable such as an array expression or string to be expanded in
        places where zero or more arguments (for function calls) or elements (for array literals) expected, or an object
        expression to be expanded in places where zero or more key-value pairs (for object literals) are expected.
        <br>
        <br> let arr = [1, 2, 3, 4, 5];
        <br>
        <br> function multiply(a, b, c, d, e) {
        <br> return a * b * c * d * e;
        <br> }
        <br>
        <br> // Spreads the array as seperate parameters
        <br> console.log(multiply(...arr)); // 120
        <br>
        <br> -- Consider a scenario where we have to find the largest number from the given array of numbers. The ideal
        solution will be to use Math.max with apply method.
        <br>
        <br> let arr = [1, 2, 3, 4, 5];
        <br> console.log(Math.max.apply(null, arr)); // 5
        <br>
        <br>-- The solution works perfectly but it is bit confusing, ES6 ... spread operator makes this very easy and
        simple.
        <br>
        <br> let arr = [1, 2, 3, 4, 5];
        <br> console.log(Math.max(...arr)); // 5
        <br>
        <br> JavaScript engine spills arr into individual arguments.
    </p>

    <!-- Combining multiple arrays -->
    <p>• <u><strong>Combining multiple arrays</strong></u></p>
    <p>-- With javascript ... spread operator it is easy to combine multiple arrays.
        <br>
        <br> let arr = [1, 2, 3, 4, 5];
        <br> let arr2 = [6, 7, 8, 9, 10];
        <br>
        <br> let combine = [...arr, ...arr2];
        <br> console.log(combine);
        <br> // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
        <br>
        <br> let combine2 = [0, ...arr, 11, ...arr2, 12];
        <br> console.log(combine2);
        <br> // [0, 1, 2, 3, 4, 5, 11, 6, 7, 8, 9, 10, 12]
        <br>
        <br> let combine3 = [...arr, 'prashant', ...arr2];
        <br> console.log(combine3);
        <br> // [1, 2, 3, 4, 5, 'prashant', 6, 7, 8, 9, 10]
        <br>
        <br> The ... spread operator allows us to pass all the items of arr and arr2 at the same time add extra items
        also.
    </p>

    <!-- Copying an array -->
    <p>• <u><strong>Copying an array</strong></u></p>
    <p>-- Drawbacks while copying arrays before ... spread operators.
        <br>
        <br> let arr = [1, 2, 3, 4, 5];
        <br> let copy = arr;
        <br> console.log(copy);
        <br> // [1, 2, 3, 4, 5]
        <br>
        <br> arr.push(6);
        <br> console.log(arr);
        <br> // [1, 2, 3, 4, 5, 6]
        <br>
        <br> console.log(copy);
        <br> // [1, 2, 3, 4, 5, 6]
        <br>
        <br> -- We have added an extra item to arr with arr.push(6) but the same gets updates in copy, this happens
        because arr is neve copied to copy but passed as the reference which means copy is just pointing to arr. A
        seperate solution would be to copy all the items individually using loops.
        <br> -- We can solve this issue using javascript ... spread operator.
        <br>
        <br> let arr = [1, 2, 3, 4, 5];
        <br> let copy = [...arr];
        <br> console.log(copy);
        <br> // [1, 2, 3, 4, 5]
        <br>
        <br> arr.push(6);
        <br> console.log(arr);
        <br> // [1, 2, 3, 4, 5, 6]
        <br>
        <br> console.log(copy);
        <br> // [1, 2, 3, 4, 5]
    </p>

    <!-- Use with Constructors -->
    <p>• <u><strong>Use with Constructors</strong></u></p>
    <p>-- It is not possible to directly use an array and apply with new keyword while declaring constructor. But with
        the javascript ... spread operators we can do this easily.
        <br>
        <br> let dateFields = [1970, 0, 1];
        <br> let d = new Date(...dateFields);
        <br> console.log(d);
        <br> // Thu Jan 01 1970 00:00:00 GMT+0530 (Indian Standard Time)
    </p>

    <!-- Use with Functions -->
    <p>• <u><strong>Use with Functions</strong></u></p>
    <p>-- With the introduction of ... spread operators in ES6 we can now replace the apply() method to pass the arrays
        of arguments to functions.
        <br>
        <br> let example = (a, b, c, d = 1) {
        <br> return a * b * c * d;
        <br> }
        <br> let arr = [1, 2, 3, 4, 5];
        <br>
        <br> // Before ... spread operators
        <br> console.log(example.apply(null, arr)); // 24
        <br>
        <br> // After ... spread operators
        <br> console.log(example(...arr)); // 24
        <br>
        <br> -- Array is split into the parameters and automatically passed by the javascript engine. Extra parameters
        are ignored.
    </p>
    <hr>

    <!-- Rest Parameters -->
    <h2>Rest Parameters</h2>
    <p>• Rest parametes are exactly opposite of spread operator. Spread operator is used to expand all the items of the
        arrays while rest parameters is used to condense different items to form an array. Rest parameters are also
        indicated with ... in javascript.
        <br>
        <br> let arr = [1, 2, 3, 4, 5, 6, 7, 8];
        <br> const [first, second, ...remaining] = arr;
        <br> console.log(first);
        <br> // 1
        <br> console.log(second);
        <br> // 2
        <br> console.log(remaining);
        <br> // [3, 4, 5, 6, 7, 8]
        <br>
        <br> -- The destructuring removed the first and second item and added the remaining items to the rest parameters
        ...remaining
    </p>

    <!-- Rest parameters with Functions -->
    <p>• Rest parameters with Functions</p>
    <p> -- The rest parameters are idealy used with functions instead of arguments object as it has many limitations.
        <br>
        <br> let addAll = (...args) => {
        <br> return args.reduce((a, b) => {return a + b});
        <br> }
        <br>
        <br> console.log(addAll(1, 2, 3, 4, 5, 6, 7, 8, 9, 10));
        <br> // 55
    </p>
    <hr>

    <!-- Difference between arguments and Rest parameters -->
    <h2>Difference between arguments and Rest parameters</h2>
    <p>-- arguments objects are not real arrays they are just array like objects which have only one property length,
        where as rest parameters are real arrays which has all methods like pop, forEach, push etc.</p>
    <p>-- For arguments objects we cannot use different names while with the rest parameters we can use our custom
        names.</p>
    <p>function multiply(d, ...everything){
        <br> return everything.map(e => d * e);
        <br> }
        <br>
        <br> console.log(multiply(2, 1, 2, 3, 4, 5, 6, 7, 8));
        <br> // [2, 4, 6, 8, 10, 12, 14, 16]
    </p>
    <hr>

    <script src="script.js" async defer></script>
</body>

</html>