<!DOCTYPE html>

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>Learner's Bucket</title>
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="">
</head>

<body>
    <!-- Var, Let and Const in JavaScript -->
    <h2>Var, Let and Const in JavaScript</h2>
    <!-- Var in javascript -->
    <p>• Var in javascript are function scoped, which means they are accessible outside the block scope
        even though we have declared them inside it.</p>
    <!-- Hoisting -->
    <p>• This happends because of Hoisting.</p>
    <p>var are treated as if they are at the top of the function (or global scope) regardless of where
        the actual declaration occurs, this is called hoisting.</p>
    <!-- Let in javascript -->
    <p>• Let are declared same as var but it limits the variable scope to the given block. That is why
        we should declare at the top of the block so that is accessible throughout the block and its
        sub-blocks.</p>
    <!-- Const in javascript -->
    <p>• Like let const is also block scoped. But it differs from the fact that their variable cannot
        be redeclared or change by re-assigning the value. The value remains Constant.</p>
    <hr>

    <!-- What is Temporal Dead Zone ? -->
    <h2>What is Temporal Dead Zone?</h2>
    <p>• Temporal Dead Zone is the time since when the let variable was hoisted and till it is intialized some
        value,
        the time between that is known as the Temporal Dead Zone.</p>
    <p>• So whenever you try to access a variable inside the temporal dead zone, it gives you a ReferenceError.</p>
    <p>• When the variable is inside this temporal dead zone you cannot access them and they can only be accessed
        once
        some value is initialized to them.</p>
    <p>• The let and const variables are not accessible before they are initialized with some value, and the phase
        between the starting of the execution of block in which the let or const variable is declared till that
        variable
        is being initialized is called Temporal Dead Zone for the variable.</p>
    <hr>

    <!-- Transpiler -->
    <h2>Transpiler</h2>
    <p>• If you want old or older versions of browsers to understand new features, one must use a
        transpiler.</p>
    <p>• A transpiler converts the new JavaScript code to a browser compatible javascript.</p>
    <p>• That is why babel is created.</p>
    <p>• Babel is a JavaScript compiler which converts the new Javascript to a browser compatible
        Javascript.</p>
    <hr>

    <!-- How to use Babel? -->
    <h2>How to use Babel?</h2>
    <p>• Copy the Babel cdn from babel cdn website and import this in your website.</p>
    <p>• Now after importing the cdn, we need to tell the browser that the current script which we
        are writing is in Babel.</p>
    <p>• We can do that by setting the type of the script tag.</p>
    <!-- <script type = "text/babel">
            let n = [1, 2, 3];
            let squares = n.map((e) => e * e);
        </script> -->
    <hr>

    <!-- What is the difference between Polyfilling and Transpiling? -->
    <h2>What is the difference between Polyfilling and Transpiling?</h2>
    <p>• A polyfill tries to emulate specific methods, so you can use them as if they were already
        supported by the browser (or node engine), on the other hand, A transpiler will modify your
        code and replace code by other code that does the same, which can then be executed in old
        browsers.</p>
    <p>• So you can use a polyfill if your target browser did not implement the feature you need
        to use. A transpiler, on the other hand, is more complex and will let you use the new
        language syntax and transforming your source code.</p>
    <p>• In short, a polyfill will change the code in your target browser if some of the new features
        you wanted to add are not working.</p>
    <p>• And transpiler will let us use the new code of the new features which we wanted to add,
        but will transform or convert it into the new source code first.</p>
    <hr>

    <!-- What are Template Strings -->
    <h2>What are Template Strings</h2>
    <p>• Template Literals are strings which allow embedded expressions. Before ES6 introduced them, they were
        called as Template Strings.</p>
    <p>• JavaScript strings always had limitations compared to the strings of the other programming languages. Apart
        from simple concatenation, there was not much we could have done with strings.</p>
    <p>• ECMAScript 6's template literals provided syntax for creating domain-specific languages (DSLs) for working
        with
        content in a safer way than the solutions available earlier.</p>
    <p>• With template strings we can handle following features easily : <br>
        -- Multiline Strings <br>
        -- Basic string formatting <br>
        -- HTML Escaping </p>
    <p>• Against the standard ' ' and " " quotes template literals uses back-ticks ` `.</p>
    <hr>

    <!-- JavaScript Fat Arrow Function -->
    <h2>JavaScript Fat Arrow Function</h2>
    <p>• One of the most interesting parts of ES6 is arrow functions. Arrow functions as it sounds is the new syntax =>
        of declaring a function. But it behaves differently from the traditional functions of JavaScript.</p>
    <p>-- No this, arguments, super or new.target bindings of its own. <br>
        -- We cannot use them as Constructors. <br>
        -- They do not have prototype property. <br>
        -- yield keyword cannot be used (Until in special cases). <br>
        -- Unique named parameters.</p>
    <p>• When to avoid using arrow functions in JavaScript : <br>
        -- If we want to access the this of the current function then it is better to avoid the arrow functions. <br>
        -- Also if you want to access all the arguments of the function then it is better to avoid arrow functions as
        arguments are missing or use rest operators.</p>
    <hr>

    <!-- Functions with default parameters in JavaScript -->
    <h2>Functions with default parameters in JavaScript</h2>
    <p>• Functions are really amazing in javascript as they allow to pass any numbers of parameters regardless of the
        numbers of parameters declared. Thus there is a need to handle function with default parameters.</p>
    <p>• Before exploring the default parameters of ES6, let us see how to handle it in older versions of javascript :
    </p>
    <p>•<strong> Before ES6 :</strong> <br>
        -- In javascript the function parameters were default to undefined. To handle them we had to check the
        parameters and assign values if they were undefined. <br>
        -- If we have not checked and assigned the value for by then it would have returned NaN. <br>
        -- While this approach is good but imagine we have more parameters and we have to check for every parameters and
        assign value to it. It will get quite lengthy. </p>
    <p>•<strong> After ES6 :</strong> <br>
        -- With default parameters introduction in ES6 we can now assign the default values in the function head itself.
        <br>
        -- The default value is assigned only to the undefined parameters not to the other falsy values.</p>
    <p>•<strong> Passing Functions, Arrays and Objects : </strong> <br>
        -- We could also set default parameters to be function, arrays and objects in javascript. <br>
        -- We can also set the existing parameters as the default value. <br>
        -- Default values are evaluated at call time. <br> </p>
    <p>•<strong> Destructured values with default parameters :</strong> <br>
        -- We can set the default parameters with destructuring. <br>
        -- We will use arrow (=>) function for it.</p>
    <hr>

    <!-- ES6 Object Literals -->
    <h2>ES6 Object Literals</h2>
    <p>• Applications in javascript are getting more complex with time and use lots of objects, which makes sense as
        almost everything in javascript are some types of objects.</p>
    <p>• With more objects, comes necessity to use them more efficiently and ES6 focuses heavily on improving them.</p>
    <p>• JavaScript has different types of objects used in standard as well as in the execution environment added by the
        browsers or Nodejs.</p>
    <p>• The succinct syntax of object literals for creating objects in javascript has made it so popular that JSON
        adopted the same syntax. ES6 make object literals more powerful and more succinct by extending the syntax.</p>

    • <strong>Deconstructing variables into keys and values</strong>
    <p>-- <u>Before ES6</u> :
        <br> Creating an object literal in javascript.
        <br><br> var name = 'Prashant Yadav';
        <br> var age = 23;
        <br> var nationality = 'Indian';
        <br> var designation = 'Software Engineer';
        <br><br> var user = {
        <br> name : name,
        <br> age : age,
        <br> nationality : nationality,
        <br> designation : designation
        <br> }
        <br><br> console.log(user);
        <br> // {name : 'Prashant Yadav', age : 23, nationality : 'Indian', designation : 'Software Engineer'}
    </p>
    <p>-- <u>After ES6</u> :
        <br> Creating an object literal in ES6.
        <br><br> var name = 'Prashant Yadav';
        <br> var age = 23;
        <br> var nationality = 'Indian';
        <br> var designation = 'Software Engineer';
        <br><br> var user = {
        <br> name,
        <br> age,
        <br> nationality,
        <br> designation
        <br> }
        <br><br> console.log(user);
        <br> // {name : 'Prashant Yadav', age : 23, nationality : 'Indian', designation : 'Software Engineer'}
    </p>
    <p>-- If variable name is same as the property name then we can skip assigning the value to the property and use the
        above syntax to declare objects.</p>

    • <strong>Declaring functions inside objects</strong>
    <p>-- <u>Before ES6</u> :
        <br><br> var name = 'Prashant Yadav';
        <br> var age = 23;
        <br> var nationality = 'Indian';
        <br> var designation = 'Software Engineer';
        <br><br> var user = {
        <br> name : name,
        <br> age : age,
        <br> nationality : nationality,
        <br> designation : designation,
        <br> detail : function () {
        <br> return this.name + ' is an ' + this.nationality + ' working as ' + this.designation;
        <br> }}
        <br><br>console.log(user.detail());
        <br> // Prashant Yadav is an Indian working as Software Engineer
    </p>
    <p>-- <u>After ES6</u> :
        <br><br> var name = 'Prashant Yadav';
        <br> var age = 23;
        <br> var nationality = 'Indian';
        <br> var designation = 'Software Engineer';
        <br><br> var user = {
        <br> name,
        <br> age,
        <br> nationality,
        <br> designation
        <br> detail() {
        <br> return this.name + ' is an ' + this.nationality + ' working as ' + this.designation;
        <br> }}
        <br><br> console.log(user);
        <br> // {name : 'Prashant Yadav', age : 23, nationality : 'Indian', designation : 'Software Engineer'}
    </p>
    <p>-- We no longer need to declare function keyword, we can declare the function directly with above syntax.</p>

    • <strong>Declaring functions inside objects</strong>
    <p>const math = {
        <br> add : (a, b) => a + b,
        <br> mul : (a, b) => a * b,
        <br> sub : (a, b) => a-b,
        <br> div : (a, b) => a / b,
        <br> }
        <br><br> console.log(math.add(1, 1)); // 2
        <br> console.log(math.mul(1, 1)); // 1
        <br> console.log(math.sub(1, 1)); // 0
        <br> console.log(math.div(1, 1)); // 1
    </p>

    • <strong>Dynamically define properties of an Object</strong>
    <p>-- <u>Before ES6</u> :
        <br><br> To dynamically define properties of the object in ES5 or earlier we used to first create the object and
        then modify it.
        <br><br> var name = 'name';
        <br> // create empty object
        <br><br> var user = {}
        <br> // update the object
        <br><br> var [name] = 'Prashant Yadav';
        <br><br> console.log(user.name);
        <br> // Prashant Yadav
    </p>
    <p>-- <u>After ES6</u> :
        <br><br> With ES6 we can do both the things same time. Computed property names are part of the object literal
        syntax.
        <br><br> var name = 'first';
        <br><br> var suffix = 'name';
        <br> // create empty object and assigning the value
        <br><br> var user = {
        <br> [name] : 'Prashant',
        <br> ['last ' + suffix] : 'Yadav'
        <br> }
        <br><br> console.log(user.first + ' ' + user['last name']);
        <br> // Prashant Yadav
    </p>

    • <strong>Declaring duplicate properties</strong>
    <p><u>Before ES6</u> :
        <br><br> In ES5 and earlier declaring duplicate property names inside object literals in strict mode would throw
        error.
        <br><br>'use strict';
        <br> var user = {
        <br> name : 'prashant',
        <br> name : 'golu'
        <br> }
        <br><br> // syntax error
    </p>
    <p><u>After ES6</u> :
        <br><br> In ES6 we can declare duplicate property names inside object literals in strict as well as nonstrict
        mode. It will just overwrite the existing value.
        <br><br>'use strict';
        <br> var user = {
        <br> name : 'prashant',
        <br> name : 'golu'
        <br> }
        <br><br> console.log(user.name);
        <br> // golu
    </p>
    <hr>

    <script src="script.js" async defer></script>
</body>

</html>