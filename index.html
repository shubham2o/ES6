<!DOCTYPE html>

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>Learner's Bucket</title>
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="">
</head>

<body>
    <!-- Var, Let and Const in JavaScript -->
    <h2>Var, Let and Const in JavaScript</h2>
    <!-- Var in javascript -->
    <p>• Var in javascript are function scoped, which means they are accessible outside the block scope
        even though we have declared them inside it.</p>
    <!-- Hoisting -->
    <p>• This happends because of Hoisting.</p>
    <p>var are treated as if they are at the top of the function (or global scope) regardless of where
        the actual declaration occurs, this is called hoisting.</p>
    <!-- Let in javascript -->
    <p>• Let are declared same as var but it limits the variable scope to the given block. That is why
        we should declare at the top of the block so that is accessible throughout the block and its
        sub-blocks.</p>
    <!-- Const in javascript -->
    <p>• Like let const is also block scoped. But it differs from the fact that their variable cannot
        be redeclared or change by re-assigning the value. The value remains Constant.</p>
    <hr>


    <!-- What is Temporal Dead Zone ? -->
    <h2>What is Temporal Dead Zone?</h2>
    <p>• Temporal Dead Zone is the time since when the let variable was hoisted and till it is intialized some
        value,
        the time between that is known as the Temporal Dead Zone.</p>
    <p>• So whenever you try to access a variable inside the temporal dead zone, it gives you a ReferenceError.</p>
    <p>• When the variable is inside this temporal dead zone you cannot access them and they can only be accessed
        once
        some value is initialized to them.</p>
    <p>• The let and const variables are not accessible before they are initialized with some value, and the phase
        between the starting of the execution of block in which the let or const variable is declared till that
        variable
        is being initialized is called Temporal Dead Zone for the variable.</p>
    <hr>


    <!-- Transpiler -->
    <h2>Transpiler</h2>
    <p>• If you want old or older versions of browsers to understand new features, one must use a
        transpiler.</p>
    <p>• A transpiler converts the new JavaScript code to a browser compatible javascript.</p>
    <p>• That is why babel is created.</p>
    <p>• Babel is a JavaScript compiler which converts the new Javascript to a browser compatible
        Javascript.</p>
    <hr>


    <!-- How to use Babel? -->
    <h2>How to use Babel?</h2>
    <p>• Copy the Babel cdn from babel cdn website and import this in your website.</p>
    <p>• Now after importing the cdn, we need to tell the browser that the current script which we
        are writing is in Babel.</p>
    <p>• We can do that by setting the type of the script tag.</p>
    <!-- < type = "text/babel">
            let n = [1, 2, 3];
            let squares = n.map((e) => e * e);
        </script> -->
    <hr>


    <!-- What is the difference between Polyfilling and Transpiling? -->
    <h2>What is the difference between Polyfilling and Transpiling?</h2>
    <p>• A polyfill tries to emulate specific methods, so you can use them as if they were already
        supported by the browser (or node engine), on the other hand, A transpiler will modify your
        code and replace code by other code that does the same, which can then be executed in old
        browsers.</p>
    <p>• So you can use a polyfill if your target browser did not implement the feature you need
        to use. A transpiler, on the other hand, is more complex and will let you use the new
        language syntax and transforming your source code.</p>
    <p>• In short, a polyfill will change the code in your target browser if some of the new features
        you wanted to add are not working.</p>
    <p>• And transpiler will let us use the new code of the new features which we wanted to add,
        but will transform or convert it into the new source code first.</p>
    <hr>


    <!-- What are Template Strings -->
    <h2>What are Template Strings</h2>
    <p>• Template Literals are strings which allow embedded expressions. Before ES6 introduced them, they were
        called as Template Strings.</p>
    <p>• JavaScript strings always had limitations compared to the strings of the other programming languages. Apart
        from simple concatenation, there was not much we could have done with strings.</p>
    <p>• ECMAScript 6's template literals provided syntax for creating domain-specific languages (DSLs) for working
        with
        content in a safer way than the solutions available earlier.</p>
    <p>• With template strings we can handle following features easily : <br>
        -- Multiline Strings <br>
        -- Basic string formatting <br>
        -- HTML Escaping </p>
    <p>• Against the standard ' ' and " " quotes template literals uses back-ticks ` `.</p>
    <hr>


    <!-- JavaScript Fat Arrow Function -->
    <h2>JavaScript Fat Arrow Function</h2>
    <p>• One of the most interesting parts of ES6 is arrow functions. Arrow functions as it sounds is the new syntax =>
        of declaring a function. But it behaves differently from the traditional functions of JavaScript.</p>
    <p>-- No this, arguments, super or new.target bindings of its own. <br>
        -- We cannot use them as Constructors. <br>
        -- They do not have prototype property. <br>
        -- yield keyword cannot be used (Until in special cases). <br>
        -- Unique named parameters.</p>
    <p>• When to avoid using arrow functions in JavaScript : <br>
        -- If we want to access the this of the current function then it is better to avoid the arrow functions. <br>
        -- Also if you want to access all the arguments of the function then it is better to avoid arrow functions as
        arguments are missing or use rest operators.</p>
    <hr>


    <!-- Functions with default parameters in JavaScript -->
    <h2>Functions with default parameters in JavaScript</h2>
    <p>• Functions are really amazing in javascript as they allow to pass any numbers of parameters regardless of the
        numbers of parameters declared. Thus there is a need to handle function with default parameters.</p>
    <p>• Before exploring the default parameters of ES6, let us see how to handle it in older versions of javascript :
    </p>
    <p>•<strong> Before ES6 :</strong> <br>
        -- In javascript the function parameters were default to undefined. To handle them we had to check the
        parameters and assign values if they were undefined. <br>
        -- If we have not checked and assigned the value for by then it would have returned NaN. <br>
        -- While this approach is good but imagine we have more parameters and we have to check for every parameters and
        assign value to it. It will get quite lengthy. </p>
    <p>•<strong> After ES6 :</strong> <br>
        -- With default parameters introduction in ES6 we can now assign the default values in the function head itself.
        <br>
        -- The default value is assigned only to the undefined parameters not to the other falsy values.</p>
    <p>•<strong> Passing Functions, Arrays and Objects : </strong> <br>
        -- We could also set default parameters to be function, arrays and objects in javascript. <br>
        -- We can also set the existing parameters as the default value. <br>
        -- Default values are evaluated at call time. <br> </p>
    <p>•<strong> Destructured values with default parameters :</strong> <br>
        -- We can set the default parameters with destructuring. <br>
        -- We will use arrow (=>) function for it.</p>
    <hr>


    <!-- ES6 Object Literals -->
    <h2>ES6 Object Literals</h2>
    <p>• Applications in javascript are getting more complex with time and use lots of objects, which makes sense as
        almost everything in javascript are some types of objects.</p>
    <p>• With more objects, comes necessity to use them more efficiently and ES6 focuses heavily on improving them.</p>
    <p>• JavaScript has different types of objects used in standard as well as in the execution environment added by the
        browsers or Nodejs.</p>
    <p>• The succinct syntax of object literals for creating objects in javascript has made it so popular that JSON
        adopted the same syntax. ES6 make object literals more powerful and more succinct by extending the syntax.</p>

    <!-- Deconstructing variables into keys and values -->
    • <strong>Deconstructing variables into keys and values</strong>
    <p>-- <u>Before ES6</u> :
        <br> Creating an object literal in javascript.
        <br>
        <br> var name = 'Prashant Yadav';
        <br> var age = 23;
        <br> var nationality = 'Indian';
        <br> var designation = 'Software Engineer';
        <br>
        <br> var user = {
        <br> name : name,
        <br> age : age,
        <br> nationality : nationality,
        <br> designation : designation
        <br> }
        <br>
        <br> console.log(user);
        <br> // {name : 'Prashant Yadav', age : 23, nationality : 'Indian', designation : 'Software Engineer'}
    </p>
    <p>-- <u>After ES6</u> :
        <br> Creating an object literal in ES6.
        <br>
        <br> var name = 'Prashant Yadav';
        <br> var age = 23;
        <br> var nationality = 'Indian';
        <br> var designation = 'Software Engineer';
        <br>
        <br> var user = {
        <br> name,
        <br> age,
        <br> nationality,
        <br> designation
        <br> }
        <br>
        <br> console.log(user);
        <br> // {name : 'Prashant Yadav', age : 23, nationality : 'Indian', designation : 'Software Engineer'}
    </p>
    <p>-- If variable name is same as the property name then we can skip assigning the value to the property and use the
        above syntax to declare objects.</p>

    <!-- Declaring functions inside objects -->
    • <strong>Declaring functions inside objects</strong>
    <p>-- <u>Before ES6</u> :
        <br>
        <br> var name = 'Prashant Yadav';
        <br> var age = 23;
        <br> var nationality = 'Indian';
        <br> var designation = 'Software Engineer';
        <br>
        <br> var user = {
        <br> name : name,
        <br> age : age,
        <br> nationality : nationality,
        <br> designation : designation,
        <br> detail : function () {
        <br> return this.name + ' is an ' + this.nationality + ' working as ' + this.designation;
        <br> }}
        <br>
        <br>console.log(user.detail());
        <br> // Prashant Yadav is an Indian working as Software Engineer
    </p>
    <p>-- <u>After ES6</u> :
        <br>
        <br> var name = 'Prashant Yadav';
        <br> var age = 23;
        <br> var nationality = 'Indian';
        <br> var designation = 'Software Engineer';
        <br>
        <br> var user = {
        <br> name,
        <br> age,
        <br> nationality,
        <br> designation
        <br> detail() {
        <br> return this.name + ' is an ' + this.nationality + ' working as ' + this.designation;
        <br> }}
        <br>
        <br> console.log(user);
        <br> // {name : 'Prashant Yadav', age : 23, nationality : 'Indian', designation : 'Software Engineer'}
    </p>
    <p>-- We no longer need to declare function keyword, we can declare the function directly with above syntax.</p>

    <!-- We can also declare the => fat arrow function -->
    • <strong>We can also declare the => fat arrow function</strong>
    <p>const math = {
        <br> add : (a, b) => a + b,
        <br> mul : (a, b) => a * b,
        <br> sub : (a, b) => a-b,
        <br> div : (a, b) => a / b,
        <br> }
        <br>
        <br> console.log(math.add(1, 1)); // 2
        <br> console.log(math.mul(1, 1)); // 1
        <br> console.log(math.sub(1, 1)); // 0
        <br> console.log(math.div(1, 1)); // 1
    </p>

    <!-- Dynamically define properties of an object -->
    • <strong>Dynamically define properties of an object</strong>
    <p>-- <u>Before ES6</u> :
        <br>
        <br> To dynamically define properties of the object in ES5 or earlier we used to first create the object and
        then modify it.
        <br>
        <br> var name = 'name';
        <br> // create empty object
        <br>
        <br> var user = {}
        <br> // update the object
        <br>
        <br> var [name] = 'Prashant Yadav';
        <br>
        <br> console.log(user.name);
        <br> // Prashant Yadav
    </p>
    <p>-- <u>After ES6</u> :
        <br>
        <br> With ES6 we can do both the things same time. Computed property names are part of the object literal
        syntax.
        <br>
        <br> var name = 'first';
        <br>
        <br> var suffix = 'name';
        <br> // create empty object and assigning the value
        <br>
        <br> var user = {
        <br> [name] : 'Prashant',
        <br> ['last ' + suffix] : 'Yadav'
        <br> }
        <br>
        <br> console.log(user.first + ' ' + user['last name']);
        <br> // Prashant Yadav
    </p>

    <!-- Declaring duplicate properties -->
    • <strong>Declaring duplicate properties</strong>
    <p>-- <u>Before ES6</u> :
        <br>
        <br> In ES5 and earlier declaring duplicate property names inside object literals in strict mode would throw
        error.
        <br>
        <br>'use strict';
        <br> var user = {
        <br> name : 'prashant',
        <br> name : 'golu'
        <br> }
        <br>
        <br> // syntax error
    </p>
    <p>-- <u>After ES6</u> :
        <br>
        <br> In ES6 we can declare duplicate property names inside object literals in strict as well as nonstrict
        mode. It will just overwrite the existing value.
        <br>
        <br>'use strict';
        <br> var user = {
        <br> name : 'prashant',
        <br> name : 'golu'
        <br> }
        <br>
        <br> console.log(user.name);
        <br> // golu
    </p>
    <hr>


    <!-- JavaScript Set -->
    <h2>JavaScript Set</h2>
    <p>• Before ES6 there was only one data-structure, Array which we could have used for numeric operations and for
        other non-numeric operations we had to use Objects.</p>
    <p>• Arrays came with extra methods which we could use to create stack and queue.</p>
    <p>• With the introduction of javascript Set and Map, we now have some extra data-structures in javascript's
        library.</p>
    <p>• Sets are the unique collection of values of any type, which also includes NaN and undefined.</p>

    <!-- Before ES6 -->
    <p>-- <u>Before ES6</u> :
        <br>
        <br> Before sets introduction in ES6 there was workaround which developers used to have to create sets but
        there was limitation to that workaround. Let us see that first to exactly know why there was need for it.
        <br>
        <br> var set = {};
        <br> if (!set.foo) {
        <br> set.foo = true;
        <br> }
    </p>
    <p>-- We have created an empty object and assigned true to the properties so that we can check if that value is
        present.</p>
    <p>-- This works well in the simple scenarios but when we have to use more complex situations we run into the
        limitations of the object properties.</p>
    <p>var set = {};
        <br> var key = {};
        <br> set[25] = 'prashant';
        <br> set[key] = 5;
        <br>
        <br> console.log(set['25']); // prashant
        </br> console.log(set[key]); // 5
    </p>
    <p>-- Here the object internally converts the numeric 25 and key to string '25' because object parameters must be
        string, Thus we cannot use both of them simultaneously.</p>

    <!-- After ES6 -->
    <p>-- <u>After ES6</u> :
        <br>
        <br> With introduction of Set and WeakSet in ES6 we don't have to worry about the workaround limitations.
        <br>let set = new Set([!iterable]);
        <br> if an iterable object like Array is passed then all its items will be added to the set.
        <br>
        <br> let set = new Set();
        <br> set.add(25);
        <br> set.add('25');
        <br>
        <br> let set2 = new Set([1, 2, 3, 4, 5, 6, 7, 8]);
        <br> let set3 = new Set('Prashant');
        <br>
        <br> console.log(set.size); // 2
        <br> console.log(set2.size); // 8
        <br> console.log(set3.size); // 7 ['P', 'r', 'a', 's', 'h', 'n', 't'];
    </p>
    <p>-- Sets do not convert the values while checking (Except for +0 and -0).</p>
    <p>let set = new Set();
        <br> let key = {};
        <br> let key2 = {};
        <br> set.add(key);
        <br> set.add(key2);
        <br>
        <br> console.log(set.size) // 2
    </p>

    <!-- Sets Properties -->
    • <strong>Sets Properties</strong>
    <p>-- Set.prototype.constructor <br>
        -- Set.prototype.size
    </p>

    <!-- Sets Methods -->
    • <strong>Sets Methods</strong>
    <p>-- Set.prototype.add(item)
        <br> -- Set.prototype.clear()
        <br> -- Set.prototype.delete(item)
        <br> -- Set.prototype.entries()
        <br> -- Set.prototype.foreach(callback, thisArg)
        <br> -- Set.prototype.has(item)
        <br> -- Set.prototype[@@iterator]()
        <br> -- Set.prototype.keys()
        <br> -- Set.prototype.values()
    </p>

    <!-- Iterating with javascript Set -->
    • <strong>Iterating with javascript Set</strong>
    <p>-- <u>Simple Iteration</u>
        <br>
        <br> let set = new Set();
        <br> set.add(1);
        <br> set.add(2);
        <br> set.add(3);
        <br> set.add(4);
        <br>
        <br> // foreach loop
        <br> set.forEach((e) => {console.log(e);});
        <br> // 1
        <br> // 2
        <br> // 3
        <br> // 4
        <br>
        <br> for of loop
        <br> for (let item of set) {console.log(item);}
        <br> // 1
        <br> // 2
        <br> // 3
        <br> // 4
    </p>

    <!-- Iterating objects of Set -->
    <p>-- <u>Iterating objects of Set</u>
        <br>
        <br> let set = new Set();
        <br> set.add(1);
        <br> set.add('prashant');
        <br> set.add({a: 1, b: 2, c:3, d:4});
        <br>
        <br> for (let item of set.keys()) {
        <br> console.log(item);
        <br> }
        <br> // 1
        <br> // prashant
        <br> // {a: 1, b: 2, c: 3, d: 4}
        <br>
        <br> for (let item of set.values()) {
        <br> console.log(item);
        <br> }
        <br> // 1
        <br> // prashant
        <br> // {a:1, b:2, c:3, d:4}
        <br>
        <br> for (let [key, value] of set.entries()) {
        <br> console.log(key, value);
        <br> }
        <br> // 1 1
        <br> // prashant prashant
        <br> // {a:1, b:2, c:3, d:4} {a:1, b:2, c:3, d:4}
        <br>
        <br> let set = new Set();
        <br> set.add(1);
        <br> set.add('prashant');
        <br> set.add({a:1, b:2, c:3, d:4});
        <br>
        <br> // using `.next()`
        <br>const iterator = set.values();
        <br>
        <br> console.log(iterator.next().value);
        <br> // 1
        <br>
        <br> console.log(iterator.next().value);
        <br> // prashant
        <br>
        <br> console.log(iterator.next().value);
        <br> // {a:1, b:2, c:3, d:4}
    </p>
    <hr>


    <!-- WeakSets -->
    <h2>WeakSets</h2>
    <p>• A WeakSet is same as the Set except it can only store objects.</p>
    <p>let user = {name: 'Prashant Yadav', age: 23};
        <br>const users = new WeakSet(user);
    </p>
    <hr>


    <!-- Difference between Sets and WeakSets -->
    <h2>Difference between Sets and WeakSets</h2>
    <p>• WeakSets can only store objects unlike the Sets.</p>
    <p>• The add() method throws error when non-object item is passed to the WeakSet.</p>
    <p>• The has() and delete() method returns false for non-object.</p>
    <p>• WeakSets are not Iterable.</p>
    <p>• They do not have size and foreach as well.</p>
    <p> let user = {name: 'Prashant Yadav', age: 23};
        <br> let user2 = {name: 'Prashant Yadav', age: 23};
        <br> let user3 = {name: 'Prashant Yadav', age: 23};
        <br>
        <br> const users = new WeakSet();
        <br> users.add(user);
        <br> users.add(user2);
        <br> users.add(user3);
        <br>
        <br> console.log(users.has(user2)); // true
        <br>
        <br> users.delete(user2);
        <br>
        <br> console.log(users.has(user2)); // false
    </p>
    <p>• The WeakSet cleans itself once the object is deleted or if there is no reference to the object.</p>
    <p> console.log(users);
        <br> user3 = null;
        <br> console.log(users);
        <br> // WeakSet {{...}, {...}}
        <br>
        <br> // Wait for few seconds
        <br> console.log(users);
        <br> // WeakSet {{...}}
        <br> // it automatically garbage collect the object.
    </p>
    <hr>


    <!-- JavaScript Map -->
    <h2>JavaScript Map</h2>
    <p>• Before ES6 in order to store the key value pair we had to use objects. We never had any extra data structure
        except for an array.</p>
    <p>• With the introduction of JavaScript Map and Set, we have somethig extra to handle the data.</p>
    <p>• Just like Sets, Maps are also used to store the unique values except here it is key value pair.</p>

    <!-- Before ES6 -->
    <p>• <u><strong>Before ES6</strong></u>
        <br> -- Prior to the introduction of javascript Map, developers used to have a workaround to handle the key
        value pair but there was limitations to that workaround. Let us see the workaround first to see why there was
        need for the Maps :
        <br>
        <br> var map = {};
        <br> map.foo = "bar";
        <br>
        <br> // retrieving a value
        <br> let value = map.foo;
        <br> console.log(value);
    </p>
    <p>-- This approach works fine but if the situation gets more complex, then we run into the limitations of the
        object properties.
        <br>
        <br> var map = {};
        <br> map[5] = "bar";
        <br> console.log(map["5"]);
    </p>
    <p>-- Object internally converts anything to string to store the values. So the numeric 5 is converted to "5". Thus
        we cannot use numeric key. The same happens when we use objects as the key.
        <br>
        <br> var map = {};
        <br> var key = {};
        <br> var key2 = {};
        <br> map[key] = "prashant";
        <br> console.log(map[key2]); // prashant
    </p>
    <p>-- It converts object to string.</p>
    <p>-- Maps with falsy key were also difficult to handle.
        <br>
        <br> var map = {};
        <br> map.foo = false;
        <br> // checking for the existence of "foo" or a nonzero value?
        <br> if (map.foo) {
        // ...
        }
    </p>
    <p>-- Here we want to check if value is present inside the key foo but the falsy is automatically converted to the
        false. <strong>Note :</strong> we could use in operator, but that still check in the prototype of the objects,
        which make it only safe to use when an object has a null prototype.</p>

    <!-- After ES6 -->
    <p>• <u><strong>After ES6</strong></u>
        <br> -- Maps are ordered list of key value pair when key as well as value can be of any type.
        <br>
        <br> let map = new Map([iterable]);
        <br>
        <br> -- If an iterable object like Array (arrays with two elements, eg. [[1, 'one'],[2, 'two']]) whose
        elements
        are key-value pairs is passed then all its items will be added to the Map.
        <br> -- null values are treated as undefined.
        <br>
        <br> let map = new Map();
        <br> map.set(5, 'prashant');
        <br> map.set('5', 'yadav');
        <br> console.log(map.size); // 2
        <br> console.log(map.get(5)); // 'prashant'
        <br> console.log(map.get('5')); // 'yadav'
        <br>
        <br> let map2 = new Map([["name", "prashant"], ["age",, 23]]);
        <br> console.log(map2.size); // 2
        <br> console.log(map2.get('name')); // prashant
        <br>
        <br> -- we can also use objects as the key.
        <br>
        <br> let map = new Map();
        <br> let key1 = {};
        <br> let key2 = {};
        <br> map.set(key1, 'prashant');
        <br> map.set(key2, 'yadav');
        <br> console.log(map.size); // 2
        <br> console.log(map.get(key1)); // 'prashant'
        <br> console.log(map.get(key2)); // 'yadav'
    </p>

    <!-- Map Properties -->
    <p>• <strong>Map Properties</strong></p>
    <p> -- Map.prototype.constructor
        <br> -- Map.prototype.size
    </p>

    <!-- Map Methods -->
    <p>• <strong>Map Methods</strong></p>
    <p> -- Map.prototype.set(key, value)
        <br> -- Map.prototype.clear()
        <br> -- Map.prototype.delete(key)
        <br> -- Map.prototype.entries()
        <br> -- Map.prototype.foreach(callback, thisArg)
        <br> -- Map.prototype.has(key)
        <br> -- Map.prototype.get(key)
        <br> -- Map.prototype.[@@iterator]()
        <br> -- Map.prototype.keys()
        <br> -- Map.prototype.delete(key)
        <br> -- Map.prototype.values()
    </p>

    <!-- Adding item to the javascript map -->
    <p>• <strong>Adding item to the javascript map</strong></p>
    <p>let map = new Map();
        <br> map.set(1, 'prashant');
        <br> map.set(2, 'anil');
        <br> map.set(3, 'taha');
        <br> map.set(4, 'ankit');
        <br> map.set(4, 'ankit'); // ignore the duplicate values
        <br> map.set('4', 'yadav');
        <br> map.set('fullname', 'My name is Prashant Yadav');
        <br> map.set(undefined, 20);
        <br> let key = {a : 0, b : 1};
        <br> map.set(key, '25');
        <br> let key2 = function() {};
        <br> map.set(key2, 27);
        <br> map.set(null, 23);
        <br> console.log(map.size); // 9
        <br> console.log(map);
        <br>
        <br> // Map(9) {1 => "prashant", 2 => "anil", 3 => "taha", 4 => "ankit", "4" => "yadav", …}
        <br> // size: (...)
        <br> // __proto__: Map
        <br> // [[Entries]]: Array(9)
        <br> // 0: {1 => "prashant"}
        <br> // 1: {2 => "anil"}
        <br> // 2: {3 => "taha"}
        <br> // 3: {4 => "ankit"}
        <br> // 4: {"4" => "yadav"}
        <br> // 5: {"fullname" => "My name is Prashant Yadav"}
        <br> // 6: {undefined => 20}
        <br> // 7: {Object => 25}
        <br> // 8: {null => 23}
        <br> // length: 9
    </p>

    <!-- Finding item in Map -->
    <p>• <strong>Finding item in Map</strong></p>
    <p>console.log(map.has(key)); // true
        <br> console.log(map.has(null)); // true
        <br> console.log(map.has(key2)); // true
        <br> console.log(map.has(0)); // false
        <br>
        <br> -- Always pass objects as keys by storing it in variables
        <br>
        <br> let key = {a:0, b: 1};
    </p>

    <!-- Getting the value of a given key -->
    <p>• <strong>Getting the value of a given key</strong></p>
    <p> console.log(map.get(key)); // 25
        <br> console.log(map.get(null)); // 23
        <br> console.log(map.get(0)); // undefined
    </p>

    <!-- Removing an item with the given key from the Map -->
    <p>• <strong>Removing an item with the given key from the Map</strong></p>
    <p> map.delete(key);
        <br> map.delete(null);
        <br>
        <br> console.log(map.has(key)); // false
        <br> console.log(map.has(null)); // false
    </p>

    <!-- Iterating with Maps -->
    <p>• <strong>Iterating with Maps</strong></p>
    <p> -- <u>Simple Iteration</u>
        <br> map.forEach((value, key, ownerMap) => {
        <br> console.log(key + " " + value);
        <br> console.log(ownerMap === map);
        <br> });
        <br>
        <br> // 1 prashant
        <br> // true
        <br>
        <br> // 2 anil
        <br> // true
        <br>
        <br> // 3 taha
        <br> // true
        <br>
        <br> // 4 ankit
        <br> // true
        <br>
        <br> // 4 yadav
        <br> // true
        <br>
        <br> // fullname My name is Prashant Yadav
        <br> // true
        <br>
        <br> // undefined 20
        <br> // true
        <br>
        <br> // [object Object] 25
        <br> // true
        <br>
        <br> // null 23
        <br> // true
        <br>
        <br> -- We have used => arrow function, ownerMap is passed as this which equals to the current object ownerMap
        === map that is why it is returning true.
    </p>

    <!-- Using for of loop -->
    <p>• <strong>Using for of loop</strong></p>
    <p> for(const [key, val] of map) {
        <br> console.log(key, val);
        <br> }
        <br>
        <br> // 1 "prashant"
        <br> // 2 "anil"
        <br> // 3 "taha"
        <br> // 4 "ankit"
        <br> // 4 yadav
        <br> // fullname My name is Prashant Yadav
        <br> // undefined 20
        <br> // {a : 0, b : 1} 25
        <br> // f () {} 27
        <br> // null 23
    </p>

    <!-- Using Map.prototype.keys() -->
    <p>• <strong>Using Map.prototype.keys()</strong></p>
    <p> for (var key of map.keys()) {
        <br> console.log(key);
        <br> }
        <br>
        <br> // 1
        <br> // 2
        <br> // 3
        <br> // 4
        <br> // '4'
        <br> // fullname
        <br> // undefined
        <br> // {a:0, b:1}
        <br> // f () {}
        <br> // null
    </p>

    <!-- Using Map.prototype.values() -->
    <p>• <strong>Using Map.prototype.values()</strong></p>
    <p> for (var key of map.values()) {
        <br> console.log(key);
        <br> }
        <br>
        <br> // prashant
        <br> // anil
        <br> // taha
        <br> // ankit
        <br> // yadav
        <br> // My name is Prashant Yadav
        <br> // 20
        <br> // 25
        <br> // 27
        <br> // 23
    </p>

    <!-- Using Map.prototype.entries() -->
    <p>• <strong>Using Map.prototype.entries()</strong></p>
    <p>-- We can destructure the value to access them separately.
        <br>
        <br> for (let[key,value] of map.entries()) {
        <br> console.log(key + " = " + value);
        <br> }
        <br>
        <br> // 1 = prashant
        <br> // 2 = anil
        <br> // 3 = taha
        <br> // 4 = ankit
        <br> // 4 = yadav
        <br> // fullname = My name is Prashant Yadav
        <br> // undefined = 20
        <br> // [object Object] = 25
        <br> // function() {} = 27
        <br> // null = 23
    </p>
    <hr>


    <!-- WeakMaps -->
    <h2>WeakMaps</h2>
    <p>• WeakMaps are to the maps what weakSets are to the sets. In weakMap every key must be object, inserting an
        non-object will result in error. Objects are held weakly so that if there is no reference to key then that value
        will be removed from the WeakMap or garbage collected.</p>
    <p>• Note : key should be objects, but value can be anything.</p>
    <p>• let key = {}, key2 = {};
        <br> let weakMap = new WeakMap([[key1, "prashant"],[key2, 23]]);
        <br> console.log(weakMap.has(key1)); // true
        <br> console.log(weakMap.get(key1)); // "prashant"
        <br> console.log(weakMap.has(key2)); // true
        <br> console.log(weakMap.get(key2)); // 23
    </p>
    <p>• The WeakMap cleans itself once the key is deleted or if there is no reference to the key.</p>
    <p> let dad = {name : "Daddy"};
        <br> let mom = {name : "Mommy"};
        <br>
        <br> let map = new Map();
        <br> let weakMap = new weakMap();
        <br>
        <br> map.set(dad, 1);
        <br> map.set(mom, 2);
        <br>
        <br> dad = null;
        <br> mom = null;
        <br>
        <br> map;
        <br> // map(1) {{...}}
        <br>
        <br> weakMap;
        <br> // Wait for few seconds
        <br> // WeakMap {}
        <br>
        <br> -- As we can see mom was garbade collected when we set its value to null while dad is still present.
    </p>
    <hr>


    <!-- Difference between Maps and WeakMaps -->
    <h2>Difference between Maps and WeakMaps</h2>
    <p>• Passing non-objects as key will result in error.</p>
    <p>• The has(key) and delete(key) method returns false for non-object.</p>
    <p>• They have only four methods has(key), delete(key), get(key), set(key, value).</p>
    <p>• WeakMaps are not iterable.</p>
    <p>• WeakMaps are very useful when creating objects related to particular DOM elements. That way when DOM element is
        no longer associated then it will automatically be garbage collected.</p>
    <hr>


    <!-- JavaScript Spread and Rest Operator -->
    <h2>JavaScript Spread and Rest Operator</h2>
    <p>• The ... is the spread syntax that allows you to specify an array that should be split and have its items passed
        in as seperate arguments to a function.</p>
    <p>• According to MDN - The spread syntax allows an iterable such as an array expression or string to be expanded in
        places where zero or more arguments (for function calls) or elements (for array literals) expected, or an object
        expression to be expanded in places where zero or more key-value pairs (for object literals) are expected.
        <br>
        <br> let arr = [1, 2, 3, 4, 5];
        <br>
        <br> function multiply(a, b, c, d, e) {
        <br> return a * b * c * d * e;
        <br> }
        <br>
        <br> // Spreads the array as seperate parameters
        <br> console.log(multiply(...arr)); // 120
        <br>
        <br> -- Consider a scenario where we have to find the largest number from the given array of numbers. The ideal
        solution will be to use Math.max with apply method.
        <br>
        <br> let arr = [1, 2, 3, 4, 5];
        <br> console.log(Math.max.apply(null, arr)); // 5
        <br>
        <br>-- The solution works perfectly but it is bit confusing, ES6 ... spread operator makes this very easy and
        simple.
        <br>
        <br> let arr = [1, 2, 3, 4, 5];
        <br> console.log(Math.max(...arr)); // 5
        <br>
        <br> JavaScript engine spills arr into individual arguments.
    </p>

    <!-- Combining multiple arrays -->
    <p>• <u><strong>Combining multiple arrays</strong></u></p>
    <p>-- With javascript ... spread operator it is easy to combine multiple arrays.
        <br>
        <br> let arr = [1, 2, 3, 4, 5];
        <br> let arr2 = [6, 7, 8, 9, 10];
        <br>
        <br> let combine = [...arr, ...arr2];
        <br> console.log(combine);
        <br> // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
        <br>
        <br> let combine2 = [0, ...arr, 11, ...arr2, 12];
        <br> console.log(combine2);
        <br> // [0, 1, 2, 3, 4, 5, 11, 6, 7, 8, 9, 10, 12]
        <br>
        <br> let combine3 = [...arr, 'prashant', ...arr2];
        <br> console.log(combine3);
        <br> // [1, 2, 3, 4, 5, 'prashant', 6, 7, 8, 9, 10]
        <br>
        <br> The ... spread operator allows us to pass all the items of arr and arr2 at the same time add extra items
        also.
    </p>

    <!-- Copying an array -->
    <p>• <u><strong>Copying an array</strong></u></p>
    <p>-- Drawbacks while copying arrays before ... spread operators.
        <br>
        <br> let arr = [1, 2, 3, 4, 5];
        <br> let copy = arr;
        <br> console.log(copy);
        <br> // [1, 2, 3, 4, 5]
        <br>
        <br> arr.push(6);
        <br> console.log(arr);
        <br> // [1, 2, 3, 4, 5, 6]
        <br>
        <br> console.log(copy);
        <br> // [1, 2, 3, 4, 5, 6]
        <br>
        <br> -- We have added an extra item to arr with arr.push(6) but the same gets update in copy, this happens
        because arr is never copied to copy but passed as the reference which means copy is just pointing to arr. A
        seperate solution would be to copy all the items individually using loops.
        <br> -- We can solve this issue using javascript ... spread operator.
        <br>
        <br> let arr = [1, 2, 3, 4, 5];
        <br> let copy = [...arr];
        <br> console.log(copy);
        <br> // [1, 2, 3, 4, 5]
        <br>
        <br> arr.push(6);
        <br> console.log(arr);
        <br> // [1, 2, 3, 4, 5, 6]
        <br>
        <br> console.log(copy);
        <br> // [1, 2, 3, 4, 5]
    </p>

    <!-- Use with Constructors -->
    <p>• <u><strong>Use with Constructors</strong></u></p>
    <p>-- It is not possible to directly use an array and apply with new keyword while declaring constructor. But with
        the javascript ... spread operators we can do this easily.
        <br>
        <br> let dateFields = [1970, 0, 1];
        <br> let d = new Date(...dateFields);
        <br> console.log(d);
        <br> // Thu Jan 01 1970 00:00:00 GMT+0530 (Indian Standard Time)
    </p>

    <!-- Use with Functions -->
    <p>• <u><strong>Use with Functions</strong></u></p>
    <p>-- With the introduction of ... spread operators in ES6 we can now replace the apply() method to pass the arrays
        of arguments to functions.
        <br>
        <br> let example = (a, b, c, d = 1) {
        <br> return a * b * c * d;
        <br> }
        <br> let arr = [1, 2, 3, 4, 5];
        <br>
        <br> // Before ... spread operators
        <br> console.log(example.apply(null, arr)); // 24
        <br>
        <br> // After ... spread operators
        <br> console.log(example(...arr)); // 24
        <br>
        <br> -- Array is split into the parameters and automatically passed by the javascript engine. Extra parameters
        are ignored.
    </p>
    <hr>


    <!-- Rest Parameters -->
    <h2>Rest Parameters</h2>
    <p>• Rest parametes are exactly opposite of spread operator. Spread operator is used to expand all the items of the
        arrays while rest parameters is used to condense different items to form an array. Rest parameters are also
        indicated with ... in javascript.
        <br>
        <br> let arr = [1, 2, 3, 4, 5, 6, 7, 8];
        <br> const [first, second, ...remaining] = arr;
        <br> console.log(first);
        <br> // 1
        <br> console.log(second);
        <br> // 2
        <br> console.log(remaining);
        <br> // [3, 4, 5, 6, 7, 8]
        <br>
        <br> -- The destructuring removed the first and second item and added the remaining items to the rest parameters
        ...remaining
    </p>

    <!-- Rest parameters with Functions -->
    <p>• Rest parameters with Functions</p>
    <p> -- The rest parameters are ideally used with functions instead of arguments object as it has many limitations.
        <br>
        <br> let addAll = (...args) => {
        <br> return args.reduce((a, b) => {return a + b});
        <br> }
        <br>
        <br> console.log(addAll(1, 2, 3, 4, 5, 6, 7, 8, 9, 10));
        <br> // 55
    </p>
    <hr>


    <!-- Difference between arguments and Rest parameters -->
    <h2>Difference between arguments and Rest parameters</h2>
    <p>-- arguments objects are not real arrays they are just array like objects which have only one property length,
        where as rest parameters are real arrays which has all methods like pop, forEach, push etc.</p>
    <p>-- For arguments objects we cannot use different names while with the rest parameters we can use our custom
        names.</p>
    <p>function multiply(d, ...everything){
        <br> return everything.map(e => d * e);
        <br> }
        <br>
        <br> console.log(multiply(2, 1, 2, 3, 4, 5, 6, 7, 8));
        <br> // [2, 4, 6, 8, 10, 12, 14, 16]
    </p>
    <hr>


    <!-- JavaScript destructuring -->
    <h2>JavaScript destructuring</h2>
    <p>• Arrays and Objects are the heart of the javascript and we use it so much while programming. But still, even if
        we want only a few value or property from either of them we have to call them entirely. In order to make this
        simple ES6 introduced destructuring in javascript.</p>
    <p>• According to MDN - <br>
        The destructuring assignment syntax is a JavaScript expression that makes it possible to unpack value from
        arrays or properties from objects, into distinct variables.</p>

    <!-- Before ES6< -->
    <p>• <strong><u>Before ES6</u></strong>
        <br>
        <br> -- In order to access the properties of objects we had to call them like this.
        <br>
        <br> var person = {
        <br> name : 'prashant yadav',
        <br> age : 23,
        <br> role : Software Engineer
        <br> }
        <br>
        <br> var name = person.name;
        <br> var age = person.age;
        <br> var role = person.role;
        <br> console.log(name, age, role);
        <br> // prashant yadav 23 Software Engineer
    </p>

    <!-- After ES6 -->
    <p>• <strong><u>After ES6</u></strong>
        <br>
        <br> -- Now with the destructuring we have much simple syntax to access the properties of objects.
        <br> -- Object destructuring uses object literals syntax {}
        <br>
        <br> var person = {
        <br> name : 'prashant yadav',
        <br> age : 23,
        <br> role : Software Engineer
        <br> }
        <br>
        <br> let {name, age} = person;
        <br> console.log(name, age);
        <br> // prashant yadav 23
        <br>
        <br> let {name, age, role} = person;
        <br> console.log(name, age, role);
        <br> // prashant yadav 23 Software Engineer
        <br>
        <br> let {name, role} = person;
        <br> console.log(name, role);
        <br> // prashant yadav software engineer
        <br>
        <br> -- We can now access any property from the object and assign it to the variable, Here the variable name and
        the property name is same so we are just destructuring it.
        <br> -- let {role} = person; Removes the person.role and assign it the variable name role.
        <br> -- If we want to use a different variable name then we can do it like below.
        <br>
        <br> let {name : fullname, age : completeAge, role : designation} = person;
        <br>
        <br> console.log(fullname, completeAge, desgination);
        <br> // prashant yadav 23 Software Engineer
        <br>
        <br> -- let {name : fullName} pulls the person.name property and assign it to the fullname variable.
        <br> -- Default values can also be assigned to the variables.
        <br>
        <br> let person = {
        <br> name : 'prashant yadav',
        <br> age : 23
        <br> }
        <br> let {name : fullName, age : completeAge, role : designation = 'Engineer'} = person;
        <br>
        <br> console.log(fullName, completeAge, designation);
        <br> // prashant yadav 23 Engineer
    </p>

    <!-- Nested objects destructuring -->
    <p>• <strong>Nested objects destructuring</strong></p>
    <p>-- We can also use the destructuring for nested objects.
        <br>
        <br> let person {
        <br> name : 'prashant yadav',
        <br> age : 23,
        <br> address : {
        <br> street : 'random',
        <br> city : 'mumbai',
        <br> pincode : 421209
        <br> }
        <br> }
        <br>
        <br> let {address : {street, city}} = person;
        <br> console.log(street, city);
        <br> // random mumbai
        <br>
        <br> -- Custom variables with nested objects destructuring.
        <br>
        <br> let {address : {street : completeStreet, city : completeCity}} = person;
        <br> console.log(completeStreet, completeCity);
        <br> // random mumbai
    </p>
    <hr>


    <!-- Array Destructuring -->
    <h2>Array Destructuring</h2>

    <!-- Before ES6 -->
    <p>• <strong><u>Before ES6</u></strong>
        <br>
        <br> var arr = ['prashant', 23, 'engineer', 'javascript'];
        <br> var first = arr[0];
        <br> var second = arr[1];
        <br> console.log(first, second);
        <br> // prashant 23
    </p>

    <!-- After ES6 -->
    <p>• <strong><u>After ES6</u></strong>
        <br>
        <br> -- Array destructuring is similar to the object destructuring but it uses array literals syntax [].
        <br>
        <br> let arr = ['prashant', 23, 'engineer', 'javascript'];
        <br> let [first, second] = arr;
        <br> console.log(first, second);
        <br> // prashant 23
        <br>
        <br> -- If you want to skip and access values at other positions then we can do so by keeping that position
        blank.
        <br>
        <br> let [first, second] = arr;
        <br> console.log(first, , third);
        <br> // prashant engineer
        <br>
        <br> -- We have kept the seconds position blank.
        <br>
        <br> -- We can also assign default values to the variables.
        <br>
        <br> let [, second, , fourth, fifth = 'default value'] = arr;
        <br> console.log(second, fourth, fifth);
        <br> // 23 javascript default value
        <br>
        <br> -- We can also use ... spread operator to copy all the remaining array values in any variable.
        <br>
        <br> let [first, ...remaining] = arr;
        <br> console.log(first, remaining);
        <br> // prashant [23, 'engineer', 'javascript']
    </p>
    <hr>


    <!-- Nested Array Destructuring -->
    <h2>Nested Array Destructuring</h2>
    <p>• It is also possible to do nested array destructuring.</p>
    <p> let arr = ['prashant', 23, 'engineer', ['random', 'mumbai', 421209]];
        <br> let [first,,, [, city, zip, state = 'Maharashtra']] = arr;
        <br> console.log(first, city, zip, state);
        <br> // prashant mumbai 421209 Maharashtra
    </p>
    <hr>


    <!-- Swapping with Array destructuring -->
    <h2>Swapping with Array destructuring</h2>
    <p>• We can swap values very easily with an array destructuring.</p>
    <p>let first = 1;
        <br> let second = 2;
        <br> console.log(first, second);
        <br> // 1 2
        <br>
        <br> // Swap
        <br> [first, second] = [second, first];
        <br>
        <br> console.log(first, second);
        <br> // 2 1
    </p>
    <hr>


    <!-- Cloning an array with destructuring -->
    <h2>Cloning an array with destructuring</h2>
    <p>let arr = [2, 3, 5, 6]
        <br> let [ ...cloned ] = arr;
        <br> console.log(cloned);
        <br> [2, 3, 5, 6]
    </p>
    <hr>


    <!-- Mixed destructuring in javascript -->
    <h2>Mixed destructuring in javascript</h2>
    <p>• We can use array and object destructuring simultaneously.</p>
    <p>let person = {
        <br> name : 'prashant yadav',
        <br> age : 23,
        <br> address : {
        <br> street : 'random',
        <br> city : 'mumbai',
        <br> pincode : 421209
        <br> },
        <br> phone : [112124124124, 23124124124, 125151241212]
        <br> };
        <br>
        <br> let {
        <br> name,
        <br> address : {street : streetAddress},
        <br> phone : [first]
        <br> } = person;
        <br>
        <br> console.log(name, streetAddress, first);
        <br> // prashant yadav random 112124124124
    </p>
    <hr>


    <!-- Destructuring with Functions -->
    <h2>Destructuring with Functions</h2>
    <p>• We can use destructuring with parameters passed to the functions.</p>
    <p>let person = {
        <br> name : 'prashant yadav',
        <br> age : 23,
        <br> address : {
        <br> street : 'random',
        <br> city : 'mumbai',
        <br> pincode : 421209
        <br> },
        <br> phone : [112124124124, 23124124124, 125151241212]
        <br> };
        <br>
        <br> let showDetails = ({name, age}) => {
        <br> console.log(`${name} is ${age} years old`);
        <br> };
        <br>
        <br> showDetails(person);
        <br> // prashant yadav is 23 years old
    </p>
    <hr>


    <!-- Introduction to ES6 class -->
    <h2>Introduction to ES6 class</h2>
    <p>• As you might already know javascript is a prototype-based language. It was not designed to object-oriented but
        as the javascript was getting popular there were different libraries which were trying to extend javascript to
        be class based. So ES6 introduced class in javascript.</p>
    <p>• According to MDN - classes are primarily syntactically sugar ove js's existing prototype-based inheritance. The
        class syntax does not introduce a new object-oriented inheritance model to JavaScript.</p>
    <p>• Before diving deep into the javascript class, let us first see how different object-oriented concepts were
        handles through the prototype.</p>

    <!-- Before ES6 -->
    <p>• <strong><u>Before ES6</u></strong></p>
    <p>-- Functions were used to replicate class.
        <br> -- Declaring properties
        <br>
        <br> // Creating new functions
        <br> function individual(name, age) {
        <br> this.name = name;
        <br> this.age = age;
        <br> }
        <br>
        <br> -- <u>Calling the function as class</u>
        <br>
        <br> let person1 = new individual('prashant', 23);
        <br> let person2 = new individual('yogesh', 23);
        <br>
        <br> -- <u>Declaring Methods</u>
        <br>
        <br> // By declaring method inside the function
        <br> function individual(name, age) {
        <br> this.name = name;
        <br> this.age = age;
        <br> this.details = function() {
        <br> return this.name + ' is ' + this.age + ' years old.';
        <br> }
        <br> }
        <br>
        <br> // By declaring the method through prototype
        <br> individual.prototype.details = function() {
        <br> return this.name + ' is ' + this.age + ' years old.';
        <br> };
        <br>
        <br> // Calling the function
        <br> let person1 = new individual('prashant', 23);
        <br> console.log(person1);
        <br>
        <br> // "prashant is 23 years old."
    </p>

    <!-- After ES6 -->
    <p>• <strong><u>After ES6</u></strong></p>
    <p>-- There are two ways of declaring a class.
        <br>
        <br> 1) Class declarations
        <br> 2) Class expressions
    </p>
    <p>1-- <u>Class Declarations</u>
        <br>
        <br> // declaring class
        <br> class Individual {
        <br>
        <br> // declaring properties inside constructor
        <br> constructor(name, age) {
        <br> this.name = name;
        <br> this.age = age;
        <br> }
        <br>
        <br> // declaring display method
        <br> details() {
        <br> return `${this.name} is ${this.age} years old.`;
        <br> }
        <br> }
        <br>
        <br> // creating a person object from individual class
        <br> let person = new Individual('prashant', 23);
        <br>
        <br> // calling the display method
        <br> console.log(person.details());
        <br> // "prashant is 23 years old."
    </p>
    <p>2-- <u>Class Expression</u>
        <br>
        <br> We can assign the class expression to the variables.
        <br> •• Un-named class expressions
        <br> •• Named class expressions
        <br>
        <br> •• // UN-NAMED class expressions
        <br> const person = class {
        <br>
        <br> // declaring properties inside constructor
        <br> constructor(name, age) {
        <br> this.name = name;
        <br> this.age = age;
        <br> }
        <br>
        <br> // declaring display methods
        <br> display() {
        <br> return `${this.name} is ${this.age} years old.`;
        <br> }
        <br> }
        <br>
        <br> •• // NAMED class expressions
        <br> const Person = class Individual {
        <br>
        <br> // declaring properties inside constructor
        <br> constructor(name, age) {
        <br> this.name = name;
        <br> this.age = age;
        <br> }
        <br>
        <br> // declaring display method
        <br> details() {
        <br> return `${this.name} is ${this.age} years old.`;
        <br> }
        <br> }
        <br>
        <br> // creating a person object from individual class members
        <br> let person1 = new Person('prashant', 23);
        <br>
        <br> // calling the display method
        <br> console.log(person1,details());
        <br> // "prashant is 23 years old."
    </p>
    <p> -- constructor() should be declared only once.</p>
    <p> -- As we can see class works similar to the prototype based approach. But there are many advantages of using
        classes.</p>
    <p> -- Unlike functions, class declarations are not hoisted, which means variables declared inside are not
        accessible outside. They remain in temporal dead zone just like let until execution reaches the declaration.</p>
    <p> -- Code inside class runs in strict mode.</p>
    <p> -- Methods declared inside class are non-enumerable. Unlike prototype based where we had to use
        object.defineProperty() to make method non-enumerable.</p>
    <p> -- Calling the class constructor without new keyword will throw error. Also all the methods declared inside
        class lack the [[construct]] method and calling them with new keyword will result in error.</p>
    <p> -- Declaring the method name same as class name inside class will result in error.</p>

    <!-- Static methods -->
    <p>• <strong><u>Static methods</u></strong></p>
    <p> -- Static methods are only accessible by parents (class), derived child or instance of the class cannot access
        them.
        <br>
        <br> class Person{
        <br>
        <br> // declaring properties
        <br> constructor(name, age) {
        <br> this.name = name;
        <br> this.age = age;
        <br> }
        <br>
        <br> // declaring method
        <br> // accessible by all
        <br> details() {
        <br> console.log(`${this.name} is ${this.age} years old.`);
        <br> }
        <br>
        <br> // static method
        <br> // accessible only by parent
        <br> static display() {
        <br> console.log(`I am only accessible by parent.`);
        <br> }
        <br> }
        <br>
        <br> INPUT :
        <br> let person1 = new Person('prashant', 23);
        <br> person1.details();
        <br> Person.display();
        <br> person1.display();
        <br>
        <br> OUTPUT :
        <br> "prashant is 23 years old."
        <br> "I am only accessible by parent."
        <br> Uncaught TypeError : person1.display is not a function
    </p>

    <!-- Accessor Properties -->
    <p>• <strong><u>Accessor Properties</u></strong></p>
    <p> -- There are two accessor properties which we can use with class :
        <br> 1) Set :- To set the value of any property.
        <br> 2) Get :- To get the value of any property.
    </p>
    <p> class Person {
        <br>
        <br> // declaring properties
        <br> constructor(name, age) {
        <br> this.name = name;
        <br> this.age = age;
        <br> }
        <br>
        <br> // Set name
        <br> set nickName(name) {
        <br> this.name = name;
        <br> }
        <br>
        <br> // Get Name
        <br> get nickName() {
        return `your name is ${this.name}`;
        <br> }
        <br> }
        <br>
        <br> INPUT :
        <br> let person1 = new Person1('Prashant Yadav', 23);
        <br> console.log(person1.nickName);
        <br> // set the new nickName
        <br> person1.nickName = "Golu";
        <br> console.log(person1.nickName);
        <br>
        <br> OUTPUT :
        <br> "your name is Prashant Yadav"
        <br> "your name is Golu"
    </p>

    <!-- Computed method names -->
    <p>• <strong><u>Computed method names</u></strong></p>
    <p> -- Class methods and Accessor properties can computed names, that means their name can be provided at runtime.
        <br>
        <br> let myMethod = 'displayDetail';
        <br>
        <br> class Person {
        <br>
        <br> // declaring properties
        <br> constructor(name, age) {
        <br> this.name = name;
        <br> this.age = age;
        <br> }
        <br>
        <br> // declaring a method with the computed name
        <br> [myMethod]() {
        <br> return `${this.name} is ${this.age} years old.`;
        <br> }
        <br> }
        <br>
        <br> INPUT :
        <br> let person = new Person('Prashant Yadav', 23);
        <br> console.log(person.displayDetail());
        <br>
        <br> OUTPUT :
        <br> "Prashant Yadav is 23 years old."
    </p>
    <p> -- Accessor properties can also use computed methods.
        <br>
        <br> let myMethod = 'differentName';
        <br> class Person() {
        <br>
        <br> // declaring properties
        <br> constructor(name, age) {
        <br> this.name = name;
        <br> this.age = age;
        <br> }
        <br>
        <br> // Set name
        <br> set [myMethod](name) {
        <br> this.name = name;
        <br> }
        <br>
        <br> // get name
        <br> get [myMethod]() {
        <br> return `your name is ${this.name}`
        <br> }
        <br> }
        <br>
        <br> INPUT :
        <br> let person1 = new Person('Prashant Yadav', 23);
        <br> console.log(person1.differentName);
        <br>
        <br> // set the new differentName
        <br> person1.differentName = "Golu";
        <br> console.log(person1.differentName);
        <br>
        <br> OUTPUT :
        <br> "your name is Prashant Yadav"
        <br> "your name is Golu"
    </p>

    <!-- Inheritance -->
    <p>• <strong><u>Inheritance</u></strong></p>
    <p> -- Before ES6, implementing inheritance was a tedious process with prototype. Proper inheritance required
        multiple steps.</p>
    <p> function Rectangle(width, height) {
        <br> this.width = width;
        <br> this.height = height;
        <br> }
        <br>
        <br> // declaring method to calculate area;
        <br> Rectangle.prototype.getArea = function() {
        <br> return this.height * this.width;
        <br> }
        <br>
        <br> // Extending rectangle to use it as square
        <br> // using call, apply, bind
        <br> function Square(length) {
        <br> Rectangle.call(this, length, length);
        <br> }
        <br>
        <br> // Extending Methods
        <br> Square.prototype = Object.create(Rectangle.prototype, {
        <br> constructor: {
        <br> value: Square,
        <br> enumerable: true;
        <br> writable: true,
        <br> configurable: true
        <br> }
        <br> });
    </p>
    <p> var square = new Square(3);
        <br>
        <br> console.log(square.getArea()); // 9
        <br> console.log(square instanceof Square); // true
        <br> console.log(square instanceof Rectangle); // true
    </p>
    <p> -- After ES6, we can use extends keyword to achieve the inheritance.</p>
    <p> // Declaring the rectangle class
        <br> class Rectangle {
        <br> // initialize the properties
        <br> constructor(length, width) {
        <br> this.length = length;
        <br> this.width = width;
        <br> }
        <br>
        <br> // Method to calculate the area
        <br> getArea() {
        <br> return this.length * this.width;
        <br> }
        <br> }
        <br>
        <br> // Extend the Square to use Rectangle
        <br> class Square extends Rectangle {
        <br> constructor(length) {
        <br>
        <br> // same as Rectangle.call(this, length,, length)
        <br> super(length, length);
        <br> }
        <br> }
    </p>
    <p> const square = new Square(3);
        <br>
        <br> console.log(square.getArea()); // 9
        <br> console.log(square instanceof Square); // true
        <br> console.log(square instanceof Rectangle); // true
    </p>
    <p> -- Points to remember while inheriting the another class.
        <br> > If you inherit any class and declare the constructor() method inside it, you must declare super() method
        as well inside the constructor(). Failing to do so will result in error.
        <br> > If there are any static methods in the parent class then they are also accessible to the inherited class.
        <br> > new.target can be used to check the current instance of the class and where it is getting called from.
    </p>

    <!-- Derived class form expression -->
    <p>• <strong><u>Derived class form expression</u></strong></p>
    <p> -- One of the most powerful features of ES6 class is the ability to derive from a class from an expression.</p>
    <p> -- You can use extends with any expression as long as the expression resolves to a function with [[Construct]]
        and a prototype.</p>
    <p> // A function declaration
        <br> function Rectangle(length, width) {
        <br> this.length = length;
        <br> this.width = width;
        <br> }
        <br>
        <br> // Adding method to the function
        <br> Rectangle.prototype.constructor = function() {
        <br> return this.length * this.width;
        <br> };
        <br>
        <br> // Extending the rectangle function
        <br> class Square extends Rectangle {
        <br> constructor(length) {
        <br> super(length, length);
        <br> }
        <br> }
    </p>
    <p> INPUT :
        <br> let x = new Square(3);
        <br> console.log(x.getArea()); // 9
        <br> console.log(x instanceof Rectangle); // true
    </p>
    <p> -- With this powerful feature, we can inherit the inbuilt functions as well. The only clause is that they should
        have [[construct]] method and a prototype.</p>

    <!-- Extending the Array -->
    <p>• <strong><u>Extending the Array</u></strong></p>
    <p> class MyArray extends Array {
        <br> // empty
        <br> }
        <br>
        <br> var colors = new MyArray();
        <br> colors[0] = "red";
        <br> console.log(colors.length); // 1
        <br>
        <br> colors.length = 0;
        <br> console.log(colors[0]); // undefined
    </p>
    <p> -- MyArray inherits directly from from the array, as array has [[construct]] method as well as prototype.</p>
    <p> class Country extends Array {
        <br> // use rest operator to grab all the persons
        <br> constructor(name, ...persons) {
        <br> // pass all the students to the array
        <br> super(...persons);
        <br> this.country = country;
        <br> }
        <br>
        <br> // Method to add new person
        <br> add(person) {
        <br> this.push(person);
        <br> }
        <br> }
        <br>
        <br> INPUT :
        <br> const myCountry = new Country('India',
        <br> {name : "Prashant", age : 23},
        <br> {name : "Yogesh", age : 24},
        <br> {name : "Pranav", age : 23},
        <br> {name : "Sachin", age : 23},
        <br> );
        <br>
        <br> myCountry.add({name : "Aditya", age : 24});
        <br> console.log(myCountry[4]);
        <br>
        <br> // loop the data
        <br> for(const persons of myCountry) {
        <br> console.log(persons);
        <br> }
        <br>
        <br> OUTPUT :
        <br> // myCountry[4]
        <br> Object {
        <br> age : 24,
        <br> name : "Aditya"
        <br> }
        <br>
        <br> // Loop
        <br> Object {
        <br> age : 23,
        <br> name : "Prashant"
        <br> }
        <br> Object {
        <br> age : 24,
        <br> name : "Yogesh"
        <br> }
        <br> Object {
        <br> age : 23,
        <br> name : "Pranav"
        <br> }
        <br> Object {
        <br> age : 23,
        <br> name : "Sachin"
        <br> }
        <br> Object {
        <br> age : 24,
        <br> name : "Aditya"
        <br> }
    </p>
    <hr>


    <!-- ES6 Modules -->
    <h2>ES6 Modules</h2>
    <p>• Javascript was mostly used for functional programming. If we ever wanted to make the code modular we had to
        seperate the code in different files and load them as scripts.</p>
    <p>• With ES6 it is now possible to import the code from one file to another as Modules. Modules are javascript
        files that can be loaded in a different mode. This was necessary because modules have different semantics.</p>

    <!-- Advantages of using modules -->
    <p>• <strong><u>Advantages of using modules</u></strong>
        <br> -- Module code always run in strict mode.
        <br> -- Variables created inside the module are module scoped only. They are never added to the global scope.
        <br> -- Value of this in top level module is undefined.
        <br> -- Module should export the code inorder to make it accessible.
        <br> -- Module can import another modules as well.
    </p>
    <p>• The real power of modules is the ability to export and import only bindings you need, rather than whole code.
    </p>

    <!-- Exporting Modules -->
    <p>• <strong><u>Exporting Modules</u></strong>
        <br>
        <br><strong>-- Basic Exporting</strong>
        <br> // export properties
        <br> export var name = "Prashant Yadav";
        <br> export let age = 23;
        <br> export const nationality = "Indian";
        <br>
        <br> // export methods
        <br> export function add(num1, num2) {
        <br> return num1 + num2;
        <br> }
        <br>
        <br> // export class
        <br> export class Addition{
        <br> constructor(num1, num2) {
        <br> this.num1 = num1;
        <br> this.num2 = num2;
        <br> }
        <br>
        <br> add() {
        <br> return this.num1 + this.num2;
        <br> }
        <br> }
        <br>
        <br> // This is private as we are not exporting it
        <br> let rectangle = (width, rectangle) => {
        <br> return width * height;
        <br> }
        <br>
        <br> let square = (length) => {
        <br> return rectangle(length, length);
        <br> }
        <br>
        <br> // exporting square separately
        <br> export { square };
    </p>
    <p>There are a few things you should remember while exporting the modules :
        <br> -- You can export as many modules as you want from a single file.
        <br> -- function and class names should be specified if you are not exporting them as default.
        <br> -- There can be only one default module exported.
    </p>

    <!-- Exporting Default Module -->
    <p>• <strong><u>Exporting Default Module</u></strong></p>
    <p> -- The default value for a module is a single variable, function or class specified by the default keyword.</p>
    <p> // exporting anonymous function
        <br> export default function(num1, num2) {
        <br> return num1 + num2;
        <br> }
        <br>
        <br> // exporting anonymous class
        <br> export default class {
        <br> constructor(num1, num2) {
        <br> this.num1 = num1;
        <br> this.num2 = num2;
        <br> }
        <br>
        <br> add() {
        <br> return this.num1 + this.num2;
        <br> }
        <br> }
        <br>
        <br> // exporting named function
        <br> let add = function(num1, num2) => {
        <br> return num1 + num2;
        <br> }
        <br>
        <br> export default add;
        <br> // OR
        <br> export {add as default}
        <br>
        <br> // exporting multiple values
        <br> export let name = 'prashant';
        <br> export let age = 23;
        <br> export default function(name, age) {
        <br> return `${name} is ${age} years old`;
        <br> }
    </p>

    <!-- Renaming export modules -->
    <p>• <strong><u>Renaming export modules</u></strong></p>
    <p> -- We can rename the module name while exporting them.
        <br> // exporting named function
        <br> let add = function(num1, num2) => {
        <br> return num1 + num2;
        <br> }
        <br>
        <br> export {add as sum};
    </p>

    <!-- Importing Modules -->
    <p>• <strong><u>Importing Modules</u></strong></p>
    <p> -- When we import the module the binding to which we assign the values act as const variable. We cannot
        re-declare them and/or use them as variables, function, class.</p>
    <p> -- Note :- ./, /, ../ indicates the directory listing. Use them accordingly to find your files.</p>

    <!-- > Basic Importing -->
    <p><strong>> Basic Importing</strong>
        <br> // import single
        <br> import { add } from './module.js';
        <br>
        <br> console.log(add(1, 2)); // 3
    </p>

    <!-- Importing multiple modules -->
    <p><strong>> Importing multiple modules</strong>
        <br> // import multiple
        <br> import { name, age } from './module.js';
        <br> console.log(add(name, age));
        <br> // 'Prashant', 23
    </p>

    <!-- > Importing all modules -->
    <p><strong>> Importing all modules</strong>
        <br> // import all the modules
        <br> import * from './module.js'
        <br> console.log(name, age);
        <br> console.log(add(1, 2));
        <br> // 'Prashant', 23
        <br> // 3
    </p>
    <p> -- Note! We cannot change the value of imported binding directly. We have to do it explicitly through the
        imported module.</p>
    <p> // export data
        <br> export name = 'prashant';
        <br> export function updateName(val) {
        <br> name = val;
        <br> }
        <br>
        <br> // import data
        <br> import {name, updateName} from './example.js';
        <br> console.log(name); // prashant
        <br> updateName('pranav');
        <br> console.log(name); // pranav
        <br> name = 'sachin'; // syntax error
    </p>

    <!-- > Importing default modules -->
    <p><strong>> Importing default modules</strong>
        <br> -- We can give any name to default modules
        <br> // importing default modules
        <br> import sum from './example.js'
        <br>
        <br> // Exporting multiple values with one default value
        <br> export let name = 'prashant';
        <br> export let age = 23;
        <br> export function(name, age) {
        <br> return `${name} is ${age} years old.`;
        <br> }
        <br>
        <br> import display, {name, age} from './modules.js';
        <br> // OR
        <br> import {display as default, name, age} from './module.js';
        <br>
        <br> console.log(display(name, age));
        <br> // "prashant is 23 years old."
    </p>

    <!-- > Importing default modules -->
    <p><strong>> Importing default modules</strong>
        <br> -- We can rename the module name while importing them.
        <br>
        <br> // Renaming modules while importing
        <br> import {sum as add} from './module.js';
    </p>

    <!-- > Re-exporting imported modules -->
    <p><strong>> Re-exporting imported modules</strong>
        <br> -- We can re-export the imported modules.
        <br> // Basic
        <br> import { add } from './module.js';
        <br> export { add }
        <br>
        <br> // In single line
        <br> export { add } from './module.js';
        <br>
        <br> // Renaming nad exporting
        <br> export { add as sum } from './module.js';
        <br>
        <br> // Exporting all modules
        <br> export * from './module.js';
    </p>

    <!-- > Loading modules in browser -->
    <p><strong>> Loading modules in browser</strong>
        <br> -- Even before ES6 browsers hand different ways to import files.
        <br>
        <br> -- Load different files with script element and src.
        <br> -- Embedding inline code with script element and without src.
        <br>
        <br> -- But browsers have now updated themselves to handle the modular code.
        <br> -- We can use type attribute to use the import and export.
        <!-- // load the file
        <script script src="module.js" type="module"> </script>
        
        // load the inline script
        <script script type="module">
            import { add } from './modules.js';
            
            console.log(add(1, 2));
        </script>
        -->
    </p>
    <hr>


    <!-- JavaScript Symbol -->
    <h2>JavaScript Symbol</h2>
    <p>• Before introduction of symbol in ES6, it was very hard to define the private variables. Developers mostly used
        to do a workaround of using closure to make variables private. But now symbols can be used to create private
        object members. Symbols are added as a primitive type just like strings, numbers, booleans, null and undefined.
    </p>
    <p>• We can create symbols in javascript by using Symbol() function.</p>
    <p> let name = Symbol();
        <br> let details = {};
        <br> details[name] = 'Prashant Yadav';
        <br> console.log(details[name]);
        <br> // "Prashant Yadav"
        <br>
        <br> let fullName = symbol();
    </p>
    <p>• As symbols are primitve values, we cannot use them as a constructor. Calling symbol with new keyword like new
        Symbol() with throw an error.</p>
    <p>• Symbol function also accepts an argument which is used to describe the symbol.</p>
    <p> let name = Symbol('Full Name');
        <br> let details = {};
        <br> details[name] = 'Prashant Yadav';
        <br>
        <br> console.log(details[name]);
        <br> // "Prashant Yadav"
        <br>
        <br> console.log(name);
        <br> // Symbol(Full Name);
    </p>
    <p>• The description is stored internally and is read whenever the Symbol.toString() method is called implicitly or
        explicitly.</p>
    <p>• Symbols are always unique. Even if declared with same description.</p>
    <p> let details = {};
        <br> let firstName = Symbol('Full Name');
        <br> details[firstName] = 'Prashant';
        <br>
        <br> console.log(details[firstName]);
        <br> // "Prashant"
        <br>
        <br> let secondName = SYmbol('Full Name');
        <br> details[secondName] = 'Yadav';
        <br>
        <br> console.log(details[secondName]);
        <br> // "Yadav"
        <br>
        <br> console.log(firstName == secondName);
        <br> // false
    </p>
    <p>• As we see we have created two different Symbols with same description still they are not same.</p>

    <!-- Different ways to define Symbol in Javascript -->
    <p><strong>• <u>Different ways to define Symbol in Javascript</u></strong></p>
    <p> -- We can use Symbol where-ever we use a computed property name.

        <br>
        <!-- As a dynamic object property -->
        <br> > <u>As a dynamic object property</u>
        <br>
        <br> let firstName = Symbol('First Name');
        <br> let lastName = Symbol('Last Name');
        <br> let details = {
        <br> [firstName] = 'Prashant'
        <br> [lastName] = 'Yadav'
        <br> };
        <br>
        <br> console.log(details[firstName]);
        <br> // Prashant
        <br>
        <br> console.log(details[lastName]);
        <br> // Yadav
        <br>
        <br>
        <!-- Using Object.defineProperty() -->
        > <u>Using Object.defineProperty()</u>
        <br>
        <br> let firstName = Symbol('First Name');
        <br> let lastName = Symbol('Last Name');
        <br> let name = {};
        <br>
        <br> Object.defineProperty(details ,firstName, {
        <br> value : 'Prashant',
        <br> writable : false
        <br> });
        <br>
        <br> Object.defineProperty(details ,lastName, {
        <br> value : 'Yadav',
        <br> writable : false
        <br> });
        <br>
        <br> console.log(details[firstName]);
        <br> // Prashant
        <br>
        <br> console.log(details[lastName]);
        <br> // Yadav
        <br>
        <br>
        <!-- Using object.defineProperties() -->
        > <u>Using object.defineProperties()</u>
        <br>
        <br> let firstName = Symbol('First Name');
        <br> let lastName = Symbol('Last Name');
        <br> let details = {};
        <br>
        <br> Object.defineProperties(details, {
        <br> [firstName] : {
        <br> value : 'Prashant',
        <br> writable : true
        <br> },
        <br> [lastName] : {
        <br> value : 'Yadav',
        <br> writable : false
        <br> }
        <br> });
        <br>
        <br> console.log(details[firstName]);
        <br> // Prashant
        <br>
        <br> console.log(details[lastName]);
        <br> // Yadav
    </p>

    <!-- Using Symbol globally in javascript -->
    <p><strong>• <u>Using Symbol globally in javascript</u></strong></p>
    <p> -- We may sometimes want to use the same symbol with the different parts of our code. It is difficult to keep
        track of the symbol across large code base.</p>
    <p> -- In order to make our work easy, ES6 provides us a function called Symbol.for() which stores the Symbol in
        global registry. It accepts a single parameter description Symbol.or('name') and checks if a Symbol with same
        description exits or not. It exists then it returns the existing else it will create a new one.</p>
    <p> let details = {};
        <br>
        <br> let firstName = Symbol.for('name');
        <br> details[firstName] = 'Prashant';
        <br> console.log(details[firstName]);
        <br> // 'Prashant'
        <br>
        <br> let lastName = Symbol.for('name');
        <br> details[lastName] = 'Yadav';
        <br> console.log(details[lastName]);
        <br> // 'Yadav'
        <br>
        <br> console.log(firstName); // Symbol(name)
        <br> console.log(lastName); // Symbol(name)
        <br>
        <br> console.log(firstName === lastName);
        <br> // true
    </p>

    <!-- Checking current Symbol being used -->
    <p><strong>• <u>Checking current Symbol being used</u></strong></p>
    <p> -- There is an another function Symbol.keyFor(Symbol) which is used to check the current Symbol being used in
        global registry. It takes the Symbol as input and returns the description of the Symbol.</p>
    <p> let firstName = Symbol.for('name');
        <br> let lastName = Symbol.for('name');
        <br> let middleName = Symbol('abc');
        <br>
        <br> console.log(Symbol.keyFor(firstName));
        <br> // "name"
        <br>
        <br> console.log(Symbol.keyFor(lastName));
        <br> // "name"
        <br>
        <br> console.log(Symbol.keyFor(middleName));
        <br> // undefined
        <br>
        <br> As Symbol('abc') is not stored in the global registry. It returns undefined.
    </p>

    <!-- Retrieving Symbol Properties -->
    <p><strong>• <u>Retrieving Symbol Properties</u></strong></p>
    <p> -- We know that we can use Symbol as object property but we cannot retrieve it using existing object methods
        like Object.keys() Object.getOwnPropertyNames() as they return all enumerable property names.</p>
    <p> let Office = {
        <br> [Symbol("Tom")] : "CEO",
        <br> [Symbol("Mark")] : "CTO",
        <br> [Symbol("Mark")] : "CIO",
        <br> }
        <br>
        <br> for(person in office) {
        <br> console.log(person);
        <br> }
        <br>
        <br> // undefined
    </p>
    <p> -- As symbol is not enumerable, ES6 provides us a function which we can use to retrieve Symbols.
        Object.getOwnPropertySymbols() returns an array of own property Symbols.</p>
    <p> let office = {
        <br> [Symbol("Tom")] : "CEO",
        <br> [Symbol("Mark")] : "CTO",
        <br> [Symbol("Mark")] : "CIO",
        <br> }
        <br>
        <br> const symbols = Object.getOwnPropertySymbols(office);
        <br> console.log(symbols);
        <br> /* (3) [Symbol(Tom), Symbol(Mark), Symbol(Mark)]
        <br> 0: Symbol(Tom)
        <br> 1: Symbol(Mark)
        <br> 2: Symbol(Mark)
        <br> length: 3
        <br> __proto__: Array(0)
        <br> */
    </p>
    <p> -- We can use this array of own property Symbols along with map to retrieve all the values.</p>
    <p> let office = {
        <br> [Symbol("Tom")] : "CEO",
        <br> [Symbol("Mark")] : "CTO",
        <br> [Symbol("Mark")] : "CIO",
        <br> }
        <br>
        <br> const symbols = Object.getOwnPropertySymbols(office);
        <br> const values = symbols.map(symbol => office[symbol]);
        <br>
        <br> for (let value in values) {
        <br> console.log(values[value]);
        <br> }
        <br>
        <br> // CEO
        <br> // CTO
        <br> // CIO
    </p>

    <!-- JavaScript Symbol Methods -->
    <p><strong>• <u>JavaScript Symbol Methods</u></strong></p>
    <p> > <u>Symbol.hasInstance</u>
        <br> -- It is used by instanceOf to check the inheritance of the object.
    </p>
    <p> > <u>Symbol.isConcatSpreadable</u>
        <br> -- Returns a boolean value. It is used to indicate Array.prototype.concat() that it should flatten the
        collection passed to it.
    </p>
    <p> > <u>Symbol.iterator</u>
        <br> -- Return's an iterator.
    </p>
    <p> > <u>Symbol.match</u>
        <br> -- Used by string.prototype.match() to compare strings.
    </p>
    <p> > <u>Symbol.replace</u>
        <br> -- Used by String.prototype.replace() to replace substring.
    </p>
    <p> > <u>Symbol.search</u>
        <br> -- Used by String.prototype.search() to find substrings.
    </p>
    <p> > <u>Symbol.split</u>
        <br> -- Used by String.prototype.split() to split string in array of characters.
    </p>
    <p> > <u>Symbol.species</u>
        <br> -- Constructor to create derived objects.
    </p>
    <p> > <u>Symbol.toPrimitive</u>
        <br> -- Returns the primitive value of the object.
    </p>
    <p> > <u>Symbol.toStringTag</u>
        <br> -- A string used by Object.prototype.toString() to create an object description.
    </p>
    <p> > <u>Symbol.unscopables</u>
        <br> -- An object whose properties are the names of object properties that should not be included in a with
        statement.
    </p>
    <hr>


    <!-- JavaScript Iterator -->
    <h2>JavaScript Iterator</h2>
    <p>• JavaScript has a traditional way of iterating on the objects with loops like for, while, which need to keep
        track of each item in the collection. But this approach creates many complexities when we have to do nested
        iterations. We need to initialize a variable for each loop and keep track of them.</p>
    <p>• To solve this, ES6 has introduced iterators which makes working with a collection of items easier. Iterators,
        when called, returns the next object of the collection.</p>

    <!-- What are javascript iterator? -->
    <p><strong>• <u>What are javascript iterator?</u></strong></p>
    <p> -- Iterators are just objects with a set of an interface designed for iteration. Each iterator object has a
        next() methods that returns an object. Each returned object has two properties |value| the next value and |done|
        a boolean indicating that this is the last item.</p>
    <p> -- The iterator keeps track of the current item in the collection and with each next() call returns the
        appropriate next value.</p>
    <p> function * numbers() {
        <br> yield 1;
        <br> yield 2;
        <br> yield 3;
        <br> }
        <br>
        <br> let iterator = numbers();
        <br> console.log(iterator.next());
        <br> // {value : 1, done : false}
        <br>
        <br> console.log(iterator.next());
        <br> // {value : 2, done : false}
        <br>
        <br> console.log(iterator.next());
        <br> // {value : 3, done : false}
        <br>
        <br> console.log(iterator.next());
        <br> // {value : 4, done : true}
    </p>
    <p> -- Here we have used a generator to create the iterator.</p>

    <!-- What are generators? -->
    <p><strong>• <u>What are generators?</u></strong></p>
    <p> -- A generator is a function that returns an iterator. They are indicated by * and uses yield keyword.</p>
    <p> function * createIterator() {
        <br> yield * "value";
        <br> yield 2;
        <br> yield object = {};
        <br> }
    </p>
    <p> -- The * before createIterator() makes this function a generator. yield keyword specifies what value the
        function should return when next() method is called.</p>
    <p> -- The generator function stops the execution after each yield statement. yield can only be used inside the
        generator functions.</p>
    <p> function * createIterator() {
        <br> let friends = ['Pranav', 'Sachin', 'Panam', 'Yogesh', 'Abhilash'];
        <br> for (let i = 0; i < friends.length; i++) { <br> yield friends[i];
            <br> }
            <br> }
            <br>
            <br> let iterator = createIterator();
            <br> console.log(iterator.next());
            <br> // {value: 'Pranav', done : false}
            <br>
            <br> console.log(iterator.next());
            <br> // {value: 'Sachin', done : false}
            <br>
            <br> console.log(iterator.next());
            <br> // {value: 'Panam', done : false}
            <br>
            <br> console.log(iterator.next());
            <br> // {value: 'Yogesh', done : false}
    </p>
    <p> -- Generators are one of the most important features of ES6. As they are just functions so they can be used
        anywhere.</p>

    <!-- Generator Return Statements -->
    <p><strong>• <u>Generator Return Statements</u></strong></p>
    <p> -- As generators are function we can specify return statement both to exit early and specify a return value for
        the last call to the next() method.</p>
    <p> function * createIterator() {
        <br> let friends = ['Pranav', 'Sachin', 'Panam', 'Yogesh', 'Abhilash'];
        <br> for (let i = 0; i < friends.length; i++) { <br> if (i == 2) {
            <br> return 'arun';
            <br> }
            <br> yield friends[i];
            <br> }
            <br> }
            <br>
            <br> let iterator = createIterator();
            <br> console.log(iterator.next());
            <br> // {value : 'Pranav', done : false}
            <br>
            <br> console.log(iterator.next());
            <br> {value : 'Sachin', done : false}
            <br>
            <br> console.log(iterator.next());
            <br> {value : 'arun', done : false}
    </p>

    <!-- Passing value to generators -->
    <p><strong>• <u>Passing value to generators</u></strong></p>
    <p> -- When an argument is passed to the next() method, that argument becomes the value of the yield statement
        inside a generator.</p>
    <p> function * createIterator(){
        <br> let first = yield 1;
        <br> let second = yield first + 5;
        <br> yield second + 6;
        <br> }
        <br>
        <br> let iterator = createIterator();
        <br>
        <br> console.log(iterator.next());
        <br> // "{ value: 1, done: false }"
        <br>
        <br> console.log(iterator.next(4));
        <br> // "{ value: 9, done: false }"
        <br>
        <br> console.log(iterator.next(5));
        <br> // "{ value: 11, done: false }"
        <br>
        <br> console.log(iterator.next());
        <br> // "{ value: undefined, done: true}"
    </p>

    <!-- Generators Objects -->
    <p><strong>• <u>Generators Objects</u></strong></p>
    <p> -- Generators can also be added to the objects.</p>
    <p> let friends = {
        <br> createIterator : function * (items) {
        <br> for (let i = 0; i < items.length; i++) { <br> yield items[i];
            <br> }
            <br> },
            <br>
            <br> * createIterator2(items) {
            <br> for (let i = 0; i < items.length; i++) { <br> yield items[i];
                <br> }
                <br> }
                <br> };
                <br>
                <br> let iterator = friends.createIterator(['Pranav', 'Sachin', 'Panam', 'Yogesh', 'Abhilash']);
                <br>
                <br> console.log(iterator.next());
                <br> // {value: 'Pranav', done: false}
                <br>
                <br> console.log(iterator.next());
                <br> // {value: 'Sachin', done: false}
                <br>
                <br> let iterator2 = friends.createIterator(['goku', 'krillin', 'vegeta']);
                <br>
                <br> console.log(iterator2.next());
                <br> // {value: 'goku', done: false}
                <br>
                <br> console.log(iterator2.next());
                <br> // {value: 'krillin', done: false}
    </p>

    <!-- Iterable -->
    <p><strong>• <u>Iterable</u></strong></p>
    <p> -- An iterable is an object with a symbol.iterator property. It is closely related to iterators. symbol.iterator
        specifies a function that returns the iterator for the given object. All collection objects (arrays, sets and
        maps) and strings are iterables in ECMAScript6 and so they have a default iterator specified. It is designed to
        be used with new for-of.</p>

    <!-- For-of -->
    <p><strong>• <u>For-of</u></strong></p>
    <p> -- ES6 has introduced a new loop called for-of which is used to iterate over the values of the object. It can be
        used on iterators.</p>

    <!-- Default iterator for the array -->
    <p><strong>• <u>Default iterator for the array</u></strong></p>
    <p> let friends = ['Pranav', 'Sachin', 'Panam', 'Yogesh', 'Abhilash'];
        <br> let iterator = friends[Symbol.iterator]();
        <br>
        <br> console.log(iterator.next());
        <br> // {value : "Pranav", done : false}
        <br>
        <br> console.log(iterator.next());
        <br> // {value : "Sachin", done : false}
        <br>
        <br> console.log(iterator.next());
        <br> // {value : "Panam", done : false}
        <br>
        <br> -- A for-of loop calls next() on an iterable each time the loop executes and stores the value from the
        result object in a variable. The loop continues this process until the returned object's done property is true.
    </p>

    <!-- For-of with Array -->
    <p><strong>• <u>For-of with Array</u></strong></p>
    <p> let friends = ['Pranav', 'Sachin', 'Panam', 'Yogesh', 'Abhilash']
        <br> for (let friend of friends) {
        <br> console.log(firend);
        <br> }
        <br> // "Pranav"
        <br> // "Sachin"
        <br> // "Panam"
        <br> // "Yogesh"
        <br> // "Abhilash"
    </p>

    <!-- For-of with Objects -->
    <p><strong>• <u>For-of with Objects</u></strong></p>
    <p> -- We can also use the for-of on the objects. There are different inbuilt methods which can be used to achieve
        the same.</p>

    <!-- Built in Iterators -->
    <p><strong>• <u>Built in Iterators</u></strong></p>
    <p> -- ES6 has three types of collection objects: arrays, maps, and sets. All three have the following built-in
        iterators to help you navigate their content :
        <br>
        <br> |-- <strong>entries()</strong> - Returns an iterator whose values are a key-value pair.
        <br> |-- <strong>values()</strong> - Returns an iterator whose values of the collection.
        <br> |-- <strong>keys()</strong> - Returns an iterator whose values are a keys contained in the collection.
    </p>

    <!-- For-of with plain objects -->
    <p><strong>• <u>For-of with plain objects</u></strong></p>
    <p> let car = {
        <br> maker : "BMW",
        <br> color : "red",
        <br> year : "2010",
        <br> }
        <br>
        <br> for (let prop of Object.keys(car)) {
        <br> console.log(car[prop]);
        <br> }
        <br>
        <br> // BMW
        <br> // red color
        <br> // 2010 year
    </p>

    <!-- For-of with Maps -->
    <p><strong>• <u>For-of with Maps</u></strong></p>
    <p> let data = new Map();
        <br> data.set("prashant", 1);
        <br> data.set("pranav", 1);
        <br> data.set("sachin", 1);
        <br> data.set("panam", 1);
        <br>
        <br> for (let prop of data.entries()) {
        <br> console.log(prop);
        <br> }
        <br>
        <br> // ["prashant", 1]
        <br> // ["pranav", 1]
        <br> // ["sachin", 1]
        <br> // ["panam", 1]
    </p>

    <!-- Destructuring the data -->
    <p><strong>• <u>Destructuring the data</u></strong></p>
    <p> let data = new Map();
        <br> data.set("prashant", 1);
        <br> data.set("pranav", 2);
        <br> data.set("sachin", 3);
        <br> data.set("panam", 4);
        <br>
        <br> for (let [key, value] of data.entries()) {
        <br> console.log(`${key} at ${value}`);
        <br> }
        <br>
        <br> // prashant at 1
        <br> // pranav at 2
        <br> // sachin at 3
        <br> // panam at 4
    </p>

    <!-- For-of with Set -->
    <p><strong>• <u>For-of with Set</u></strong></p>
    <p> let data = new Set();
        <br> data.add('prashant');
        <br> data.add('pranav');
        <br> data.add('sachin');
        <br> data.add('panam');
        <br>
        <br> for (let prop of data.values()){
        <br> console.log(prop);
        <br> }
        <br>
        <br> // prashant
        <br> // pranav
        <br> // sachin
        <br> // panam
    </p>

    <!-- For-of with String -->
    <p><strong>• <u>For-of with String</u></strong></p>
    <p> let data = "prashant";
        <br>
        <br> for(let char of data){
        <br> console.log( char);
        <br> }
        <br>
        <br> /*
        <br> p
        <br> r
        <br> a
        <br> s
        <br> h
        <br> a
        <br> n
        <br> t
        <br> */
    </p>

    <!-- For-of with generators -->
    <p><strong>• <u>For-of with generators</u></strong></p>
    <p> -- Iterators created by generators are also iterables, as generators assign the symbol.iterator property by
        default.</p>
    <p> let friends = {
        <br> * createIterator(items) {
        <br> for (let i = 0; i < items.length; i++) { <br> yield items[i];
            <br> }
            <br> }
            <br> };
            <br>
            <br> let iterator = friends.createIterator(["Pranav", "Sachin", "Panam", "Yogesh", "Abhilash"]);
            <br> for (let friend of iterator) {
            <br> console.log(friend);
            <br> }
            <br>
            <br> // Pranav
            <br> // Sachin
            <br> // Panam
            <br> // Yogesh
            <br> // Abhilash
    </p>
    <hr>


    <!-- JavaScript Promise -->
    <h2>JavaScript Promise</h2>
    <p>• JavaScript is an asynchronous single-threaded programming language and to handle the asynchronous user
        interaction like click and keypress it used events.</p>
    <p> let button = document.getElementById("prashant");
        <br> button.onclick = function(event) {
        <br> console.log("Clicked");
        <br> }
    </p>
    <p>• Nodejs further advanced asynchronous programming by implementing the concept of callbacks. Callback pattern
        works the same as the event but it can pass another function as an argument which nees to be executed.</p>
    <p> readFile("example.txt", function(err, contents) {
        <br> if (err) {
        <br> throw err;
        <br> }
        <br> console.log(contents);
        <br> });
        <br> console.log("Hi!");
    </p>
    <p>• This example shows how callbacks work in the Nodejs. The readFile() reads from a file on disk and then execute
        the callback (the second argument) when completed. It pass two arguments to the callback function err and
        contents. We can now use this argument to process further.</p>
    <p>• But handling nested callback function gets tedious as we need to track multiple callbacks and cleanup
        operations. It becomes callback hell when we nest multiple callbacks.</p>
    <p> method1(function(err, result) {
        <br>
        <br> if (err) {
        <br> throw err;
        <br> }
        <br>
        <br> method2(function(err, result) {
        <br>
        <br> if (err) {
        <br> throw err;
        <br> }
        <br>
        <br> method3(function(err, result) {
        <br>
        <br> if (err) {
        <br> throw err;
        <br> }
        <br>
        <br> method4(function(err, result) {
        <br>
        <br> if (err) {
        <br> throw err;
        <br> }
        <br>
        <br> method5(result);
        <br> });
        <br>
        <br> });
        <br>
        <br> });
        <br>
        <br> });
    </p>
    <p>• Promises which are introduces in ES6 help us to handle such situations greatly. But exactly what is promise in
        javascript?</p>

    <!-- What is promise? -->
    <p><strong>• <u>What is promise</u>?</strong></p>
    <p> -- According to MDN :~ A promise is an object representing the eventual completion or failure of an asynchronous
        operation.</p>
    <p> -- Promise represent whether asynchronous code completed or failed and eventually returning its resulting value.
    </p>
    <p> let promise = readFile("example.txt");
        <br>
        <br> promise.then(function (contents) {
        <br> // fulfillment
        <br> console.log(contents);
        <br> }, function(err) {
        <br> // rejection
        <br> console.log(err.message);
        <br> });
        <br>
        <br> promise.then(function (contents) {
        <br> // fulfillment
        <br> console.log(contents);
        <br> });
        <br>
        <br> promise.then(null, function (err) {
        <br> // rejection
        <br> console.log(err.message);
        <br> });
    </p>

    <!-- Javascript promise lifecycle -->
    <p><strong>• <u>Javascript promise lifecycle</u></strong></p>
    <p> -- Each promise has a short lifecycle which represents the different state of execution of the asynchronous
        code.</p>
    <p>||-- <u> Pending </u>: Indicates that the asynchronous operation hasn't completed yet. A pending promise is
        considered unsettled.</p>
    <p>||-- <u> Resolved/Fulfilled </u>: Indicates that the asynchronous operation has completed successfully.</p>
    <p>||-- <u> Rejected</u>: Indicates that the asynchronous operation has failed due to error or some other cause.</p>
    <p> -- A promise is considered to be settled when it is either in Ressolved or Rejected state.</p>
    <p> -- We can use then() method to track the current state of the promise lifecycle. It gets called whenever promise
        change state. </p>
    <p> -- The then() method takes two arguments. First argument is called when the promise is fulfilled and second
        argument is called when it is rejected. Both of the arguments are optional.</p>

    <!-- Pending state -->
    <p><strong>• <u>Pending state</u></strong></p>
    <p> -- As soon as the promise is returned it is in the pending state.</p>
    <p> let promise = readFile("example.txt");</p>

    <!-- Resolved/Fulfilled state -->
    <p><strong>• <u>Resolved/Fulfilled state</u></strong></p>
    <p> -- When the asynchronous operation is completed successfully(fulfilled) without errors then the first argument
        of the then() is called.</p>
    <p> promise.then((content) => {
        <br> // fulfilled
        <br> console.log(content);
        <br> });
    </p>
    <p> -- We can pass the second argument as well which handles the rejection.</p>
    <p> promise.then((content) => {
        <br> // fulfilled
        <br> console.log(content);
        <br> }, (error) => {
        <br> // rejected
        <br> console.log(error);
        <br> });
    </p>

    <!-- Rejected state -->
    <p><strong>• <u>Rejected state</u></strong></p>
    <p> -- When the code fails due to error or some other case then this state is called.</p>
    <p> promise.then(null, (error) => {
        <br> // rejected
        <br> console.log(err);
        <br> });
    </p>
    <p> -- As the first argument always gets called when the operation is fulfilled we can pass null to omit it.</p>
    <p> -- There is another catch() method which we can use along with then() to handle errors. It works same as then()
        method only for rejected state.</p>
    <p> // Using then
        <br> promise.then(null, (error) => {
        <br> // rejected
        <br> console.log(err);
        <br> });
        <br>
        <br> // Using a catch
        <br> promise.catch((error) => {
        <br> // rejected
        <br> console.log(err);
        <br> });
    </p>
    <p> -- Now we don't need to pass the null as the first argument, catch() will get called only for the rejected
        state.</p>

    <!-- Creating custom promise -->
    <p><strong>• <u>Creating custom promise</u></strong></p>

    <!-- Unsettled promise -->
    <p>||-- <u> Unsettled promise</u>
        <br>
        <br> -- We can create our custom promise using __Promise__ constructor. It takes a function called executor as
        argument which initializes the promise.
        <br> -- The executor takes two arguments resolve() and reject(). When the executor is finished successfully
        then resolve() will be called. If there is any error then reject() will be called.
    </p>
    <p> const myPromise = new Promise((resolve, reject) => {
        <br> // your code goes here
        <br> });
    </p>
    <p> -- We can now use this promise to handle the execution of asynchronous code.</p>
    <p> let fs = require(".fs");
        <br>
        <br> const myPromise = new Promise((resolve, reject) => {
        <br> // your code goes here
        <br> fs.readFile(filename, { encoding : "utf8" }, function(err, contents) {
        <br>
        <br> // check for errors
        <br> if (err) {
        <br> reject(err);
        <br> return;
        <br> }
        <br>
        <br> // the read succeeded
        <br> resolve(contents);
        <br>
        <br> });
        <br>
        <br> });
        <br>
        <br> let promise = myPromise("example.txt");
        <br>
        <br> // listen for both fulfillment and rejection
        <br> promise.then((contents) => {
        <br> // fulfillment
        <br> console.log(contents);
        <br> }).catch((err) => {
        <br> // rejection
        <br> console.log(err);
        <br> });
    </p>

    <!-- Handling errors with promise -->
    <p>||-- <u> Handling errors with promise</u>
        <br>
        <br> -- The rejection handler handles the error that is thrown inside the executor function.
    </p>
    <p> let promise = new Promise(function(resolve, reject) {
        <br> throw new Error("Explosion!");
        <br> });
        <br>
        <br> promise.catch(function(error) {
        <br> console.log(error.message); // "Explosion!"
        <br> });
    </p>
    <p> -- We can also explicitly throw the error using try catch block.</p>
    <p> let promise = new Promise(function(resolve, reject) {
        <br> try {
        <br> throw new Error("Explosion!");
        <br> } catch (ex) {
        <br> reject (ex);
        <br> }
        <br> });
        <br>
        <br> promise.catch(function(error) {
        <br> console.log(error.message); // "Explosion!"
        <br> });
    </p>

    <!-- Settled promise -->
    <p>||-- <u> Settled promise</u>
        <br>
        <br> -- If you want a promise to represent just a single known value, then there are two methods that create
        settled promises given a specific value.
        <br>
        <br> >> Using promise.resolve()
        <br> The promise.resolve() method accepts a single argument and returns a promise in the fulfilled state.
        <br>
        <br> let promise = Promise.resolve(42);
        <br>
        <br> promise.then(function(value) {
        <br> console.log(value); // 42
        <br> });
        <br>
        <br> >> Using promise.reject()
        <br> It works same as the Promise.resolve() but it returns the promise in the rejected state.
        <br>
        <br> let promise = Promise.reject(42);
        <br>
        <br> promise.catch(function(value) {
        <br> console.log(value); // 42
        <br> });
    </p>

    <!-- Chaining promise -->
    <p>||-- <u> Chaining promise</u>
        <br>
        <br> -- We can chain promises one after the other, using what was returned from the previous one as the base for
        the subsequent one, whether the promise resolved or got rejected.
    </p>
    <p> const myPromise = new Promise((resolve, reject) => {
        <br> resolve();
        <br> });
        <br>
        <br> myPromise.then(data => {
        <br> // take the data returned and call a function on it
        <br> return doSomething(data);
        <br> })
        <br> .then(data => {
        <br> // log the data that we got from the previous promise
        <br> console.log(data);
        <br> })
        <br> .catch(err => {
        <br> console.error(err);
        <br> });
    </p>
    <p> -- We can return the value in the promise chain and the returned value will be handles by the following chaining
        function.</p>
    <p> const myPromise = new Promise(function(resolve, reject) {
        <br> resolve(42);
        <br> });
        <br>
        <br> myPromise.then((value) => {
        <br> console.log(value); // "42"
        <br> return value + 1 ;
        <br> }).then((value) => {
        <br> console.log(value); // "43"
        <br> return value + 5;
        <br> }).then((value) => {
        <br> console.log(value); // "48"
        <br> }).catch((err) => {
        <br> console.log(err);
        })
    </p>
    <p> -- We can do the same thing with the rejection handler as well as it will also return value.</p>
    <p> const myPromise = new Promise((resolve) {
        <br> reject(42);
        <br> });
        <br>
        <br> myPromise.catch((value) => {
        <br> // first fulfillment handler
        <br> console.log(value); "42"
        <br> return value + 1;
        <br> }).then((value) => {
        <br> // second fulfillment handler
        <br> console.log(value); "43"
        <br> });
    </p>

    <!-- Returning Promises in Promise Chains -->
    <p>||-- <u>Returning Promises in Promise Chains</u>
        <br>
        <br> -- We can also return Promise from the another promise and then handle this based on its current state.
    </p>
    <p> let p1 = new Promise(function(resolve, reject) {
        <br> resolve(42);
        <br> });
        <br>
        <br> let p2 = new Promise(function(resolve, reject) {
        <br> resolve(43);
        <br> });
        <br>
        <br> p1.then(function(value) {
        <br> // first fulfillment handler
        <br> console.log(value); // 42
        <br> return p2;
        <br> }).then(function(value) {
        <br> // second fulfillment handler
        <br> console.log(value); // 43
        <br> });
    </p>
    <p> -- As we can see the promise p1 is fulfilled and prints 42 then we returned the p2 from it which is further
        handled and prints 43.</p>
    <p> -- The seconds then() is listening to the returned promise p2. This is how it is executed.</p>
    <p> let p1 = new Promise(function(resolve, reject) {
        <br> resolve(42);
        <br> });
        <br>
        <br> let p2 = new Promise(function(resolve, reject) {
        <br> resolve(43);
        <br> });
        <br>
        <br> let p3 = p1.then(function(value) {
        <br> // first fulfillment handler
        <br> console.log(value); // 42
        <br> return p2;
        <br> });
        <br>
        <br> p3.then(function(value) {
        <br> // second fulfillment handler
        <br> console.log(value); // 43
        <br> });
    </p>
    <p> -- It simply attaches the then() handler to the returned promise.</p>
    <p> -- We can also create new promise and return it.</p>
    <p> let p1 = new Promise(function(resolve, reject) {
        <br> resolve(42);
        <br> });
        <br>
        <br> p1.then(function(value) {
        <br> console.log(value); // 42
        <br>
        <br> // create a new promise
        <br> let p2 = new Promise(function(resolve, reject) {
        <br> resolve(43);
        <br> });
        <br>
        <br> return p2
        <br> }).then(function(value) {
        <br> console.log(value); // 43
        <br> });
    </p>
    <hr>


    <script src="script.js" async defer></script>
</body>

</html>