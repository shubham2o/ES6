<!DOCTYPE html>

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>Learner's Bucket</title>
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="">
</head>

<body>
    <!-- Var, Let and Const in JavaScript -->
    <h2>Var, Let and Const in JavaScript</h2>
    <!-- Var in javascript -->
    <p>• Var in javascript are function scoped, which means they are accessible outside the block scope
        even though we have declared them inside it.</p>
    <!-- Hoisting -->
    <p>• This happends because of Hoisting.</p>
    <p>var are treated as if they are at the top of the function (or global scope) regardless of where
        the actual declaration occurs, this is called hoisting.</p>
    <!-- Let in javascript -->
    <p>• Let are declared same as var but it limits the variable scope to the given block. That is why
        we should declare at the top of the block so that is accessible throughout the block and its
        sub-blocks.</p>
    <!-- Const in javascript -->
    <p>• Like let const is also block scoped. But it differs from the fact that their variable cannot
        be redeclared or change by re-assigning the value. The value remains Constant.</p>
    <hr>

    <!-- What is Temporal Dead Zone ? -->
    <h2>What is Temporal Dead Zone?</h2>
    <p>• Temporal Dead Zone is the time since when the let variable was hoisted and till it is intialized some
        value,
        the time between that is known as the Temporal Dead Zone.</p>
    <p>• So whenever you try to access a variable inside the temporal dead zone, it gives you a ReferenceError.</p>
    <p>• When the variable is inside this temporal dead zone you cannot access them and they can only be accessed
        once
        some value is initialized to them.</p>
    <p>• The let and const variables are not accessible before they are initialized with some value, and the phase
        between the starting of the execution of block in which the let or const variable is declared till that
        variable
        is being initialized is called Temporal Dead Zone for the variable.</p>
    <hr>

    <!-- Transpiler -->
    <h2>Transpiler</h2>
    <p>• If you want old or older versions of browsers to understand new features, one must use a
        transpiler.</p>
    <p>• A transpiler converts the new JavaScript code to a browser compatible javascript.</p>
    <p>• That is why babel is created.</p>
    <p>• Babel is a JavaScript compiler which converts the new Javascript to a browser compatible
        Javascript.</p>
    <hr>

    <!-- How to use Babel? -->
    <h2>How to use Babel?</h2>
    <p>• Copy the Babel cdn from babel cdn website and import this in your website.</p>
    <p>• Now after importing the cdn, we need to tell the browser that the current script which we
        are writing is in Babel.</p>
    <p>• We can do that by setting the type of the script tag.</p>
    <!-- <script type = "text/babel">
            let n = [1, 2, 3];
            let squares = n.map((e) => e * e);
        </script> -->
    <hr>

    <!-- What is the difference between Polyfilling and Transpiling? -->
    <h2>What is the difference between Polyfilling and Transpiling?</h2>
    <p>• A polyfill tries to emulate specific methods, so you can use them as if they were already
        supported by the browser (or node engine), on the other hand, A transpiler will modify your
        code and replace code by other code that does the same, which can then be executed in old
        browsers.</p>
    <p>• So you can use a polyfill if your target browser did not implement the feature you need
        to use. A transpiler, on the other hand, is more complex and will let you use the new
        language syntax and transforming your source code.</p>
    <p>• In short, a polyfill will change the code in your target browser if some of the new features
        you wanted to add are not working.</p>
    <p>• And transpiler will let us use the new code of the new features which we wanted to add,
        but will transform or convert it into the new source code first.</p>
    <hr>

    <!-- What are Template Strings -->
    <h2>What are Template Strings</h2>
    <p>• Template Literals are strings which allow embedded expressions. Before ES6 introduced them, they were
        called as Template Strings.</p>
    <p>• JavaScript strings always had limitations compared to the strings of the other programming languages. Apart
        from simple concatenation, there was not much we could have done with strings.</p>
    <p>• ECMAScript 6's template literals provided syntax for creating domain-specific languages (DSLs) for working
        with
        content in a safer way than the solutions available earlier.</p>
    <p>• With template strings we can handle following features easily : <br>
        -- Multiline Strings <br>
        -- Basic string formatting <br>
        -- HTML Escaping </p>
    <p>• Against the standard ' ' and " " quotes template literals uses back-ticks ` `.</p>
    <hr>

    <!-- JavaScript Fat Arrow Function -->
    <h2>JavaScript Fat Arrow Function</h2>
    <p>• One of the most interesting parts of ES6 is arrow functions. Arrow functions as it sounds is the new syntax =>
        of declaring a function. But it behaves differently from the traditional functions of JavaScript.</p>
    <p>-- No this, arguments, super or new.target bindings of its own. <br>
        -- We cannot use them as Constructors. <br>
        -- They do not have prototype property. <br>
        -- yield keyword cannot be used (Until in special cases). <br>
        -- Unique named parameters.</p>
    <p>• When to avoid using arrow functions in JavaScript : <br>
        -- If we want to access the this of the current function then it is better to avoid the arrow functions. <br>
        -- Also if you want to access all the arguments of the function then it is better to avoid arrow functions as
        arguments are missing or use rest operators.</p>
    <hr>

    <!-- Functions with default parameters in JavaScript -->
    <h2>Functions with default parameters in JavaScript</h2>
    <p>• Functions are really amazing in javascript as they allow to pass any numbers of parameters regardless of the
        numbers of parameters declared. Thus there is a need to handle function with default parameters.</p>
    <p>• Before exploring the default parameters of ES6, let us see how to handle it in older versions of javascript :
    </p>
    <p>•<strong> Before ES6 :</strong> <br>
        -- In javascript the function parameters were default to undefined. To handle them we had to check the
        parameters and assign values if they were undefined. <br>
        -- If we have not checked and assigned the value for by then it would have returned NaN. <br>
        -- While this approach is good but imagine we have more parameters and we have to check for every parameters and
        assign value to it. It will get quite lengthy. </p>
    <p>•<strong> After ES6 :</strong> <br>
        -- With default parameters introduction in ES6 we can now assign the default values in the function head itself.
        <br>
        -- The default value is assigned only to the undefined parameters not to the other falsy values.</p>
    <p>•<strong> Passing Functions, Arrays and Objects : </strong> <br>
        -- We could also set default parameters to be function, arrays and objects in javascript. <br>
        -- We can also set the existing parameters as the default value. <br>
        -- Default values are evaluated at call time. <br> </p>
    <p>•<strong> Destructured values with default parameters :</strong> <br>
        -- We can set the default parameters with destructuring. <br>
        -- We will use arrow (=>) function for it.</p>
    <hr>

    <!-- ES6 Object Literals -->
    <h2>ES6 Object Literals</h2>
    <p>• Applications in javascript are getting more complex with time and use lots of objects, which makes sense as
        almost everything in javascript are some types of objects.</p>
    <p>• With more objects, comes necessity to use them more efficiently and ES6 focuses heavily on improving them.</p>
    <p>• JavaScript has different types of objects used in standard as well as in the execution environment added by the
        browsers or Nodejs.</p>
    <p>• The succinct syntax of object literals for creating objects in javascript has made it so popular that JSON
        adopted the same syntax. ES6 make object literals more powerful and more succinct by extending the syntax.</p>

    <!-- Deconstructing variables into keys and values -->
    • <strong>Deconstructing variables into keys and values</strong>
    <p>-- <u>Before ES6</u> :
        <br> Creating an object literal in javascript.
        <br>
        <br> var name = 'Prashant Yadav';
        <br> var age = 23;
        <br> var nationality = 'Indian';
        <br> var designation = 'Software Engineer';
        <br>
        <br> var user = {
        <br> name : name,
        <br> age : age,
        <br> nationality : nationality,
        <br> designation : designation
        <br> }
        <br>
        <br> console.log(user);
        <br> // {name : 'Prashant Yadav', age : 23, nationality : 'Indian', designation : 'Software Engineer'}
    </p>
    <p>-- <u>After ES6</u> :
        <br> Creating an object literal in ES6.
        <br>
        <br> var name = 'Prashant Yadav';
        <br> var age = 23;
        <br> var nationality = 'Indian';
        <br> var designation = 'Software Engineer';
        <br>
        <br> var user = {
        <br> name,
        <br> age,
        <br> nationality,
        <br> designation
        <br> }
        <br>
        <br> console.log(user);
        <br> // {name : 'Prashant Yadav', age : 23, nationality : 'Indian', designation : 'Software Engineer'}
    </p>
    <p>-- If variable name is same as the property name then we can skip assigning the value to the property and use the
        above syntax to declare objects.</p>

    <!-- Declaring functions inside objects -->
    • <strong>Declaring functions inside objects</strong>
    <p>-- <u>Before ES6</u> :
        <br>
        <br> var name = 'Prashant Yadav';
        <br> var age = 23;
        <br> var nationality = 'Indian';
        <br> var designation = 'Software Engineer';
        <br>
        <br> var user = {
        <br> name : name,
        <br> age : age,
        <br> nationality : nationality,
        <br> designation : designation,
        <br> detail : function () {
        <br> return this.name + ' is an ' + this.nationality + ' working as ' + this.designation;
        <br> }}
        <br>
        <br>console.log(user.detail());
        <br> // Prashant Yadav is an Indian working as Software Engineer
    </p>
    <p>-- <u>After ES6</u> :
        <br>
        <br> var name = 'Prashant Yadav';
        <br> var age = 23;
        <br> var nationality = 'Indian';
        <br> var designation = 'Software Engineer';
        <br>
        <br> var user = {
        <br> name,
        <br> age,
        <br> nationality,
        <br> designation
        <br> detail() {
        <br> return this.name + ' is an ' + this.nationality + ' working as ' + this.designation;
        <br> }}
        <br>
        <br> console.log(user);
        <br> // {name : 'Prashant Yadav', age : 23, nationality : 'Indian', designation : 'Software Engineer'}
    </p>
    <p>-- We no longer need to declare function keyword, we can declare the function directly with above syntax.</p>

    <!-- We can also declare the => fat arrow function -->
    • <strong>We can also declare the => fat arrow function</strong>
    <p>const math = {
        <br> add : (a, b) => a + b,
        <br> mul : (a, b) => a * b,
        <br> sub : (a, b) => a-b,
        <br> div : (a, b) => a / b,
        <br> }
        <br>
        <br> console.log(math.add(1, 1)); // 2
        <br> console.log(math.mul(1, 1)); // 1
        <br> console.log(math.sub(1, 1)); // 0
        <br> console.log(math.div(1, 1)); // 1
    </p>

    <!-- Dynamically define properties of an object -->
    • <strong>Dynamically define properties of an object</strong>
    <p>-- <u>Before ES6</u> :
        <br>
        <br> To dynamically define properties of the object in ES5 or earlier we used to first create the object and
        then modify it.
        <br>
        <br> var name = 'name';
        <br> // create empty object
        <br>
        <br> var user = {}
        <br> // update the object
        <br>
        <br> var [name] = 'Prashant Yadav';
        <br>
        <br> console.log(user.name);
        <br> // Prashant Yadav
    </p>
    <p>-- <u>After ES6</u> :
        <br>
        <br> With ES6 we can do both the things same time. Computed property names are part of the object literal
        syntax.
        <br>
        <br> var name = 'first';
        <br>
        <br> var suffix = 'name';
        <br> // create empty object and assigning the value
        <br>
        <br> var user = {
        <br> [name] : 'Prashant',
        <br> ['last ' + suffix] : 'Yadav'
        <br> }
        <br>
        <br> console.log(user.first + ' ' + user['last name']);
        <br> // Prashant Yadav
    </p>

    <!-- Declaring duplicate properties -->
    • <strong>Declaring duplicate properties</strong>
    <p>-- <u>Before ES6</u> :
        <br>
        <br> In ES5 and earlier declaring duplicate property names inside object literals in strict mode would throw
        error.
        <br>
        <br>'use strict';
        <br> var user = {
        <br> name : 'prashant',
        <br> name : 'golu'
        <br> }
        <br>
        <br> // syntax error
    </p>
    <p>-- <u>After ES6</u> :
        <br>
        <br> In ES6 we can declare duplicate property names inside object literals in strict as well as nonstrict
        mode. It will just overwrite the existing value.
        <br>
        <br>'use strict';
        <br> var user = {
        <br> name : 'prashant',
        <br> name : 'golu'
        <br> }
        <br>
        <br> console.log(user.name);
        <br> // golu
    </p>
    <hr>

    <!-- JavaScript Set -->
    <h2>JavaScript Set</h2>
    <p>• Before ES6 there was only one data-structure, Array which we could have used for numeric operations and for
        other non-numeric operations we had to use Objects.</p>
    <p>• Arrays came with extra methods which we could use to create stack and queue.</p>
    <p>• With the introduction of javascript Set and Map, we now have some extra data-structures in javascript's
        library.</p>
    <p>• Sets are the unique collection of values of any type, which also includes NaN and undefined.</p>

    <!-- Before ES6 -->
    <p>-- <u>Before ES6</u> :
        <br>
        <br> Before sets introduction in ES6 there was workaround which developers used to have to create sets but
        there was limitation to that workaround. Let us see that first to exactly know why there was need for it.
        <br>
        <br> var set = {};
        <br> if (!set.foo) {
        <br> set.foo = true;
        <br> }
    </p>
    <p>-- We have created an empty object and assigned true to the properties so that we can check if that value is
        present.</p>
    <p>-- This works well in the simple scenarios but when we have to use more complex situations we run into the
        limitations of the object properties.</p>
    <p>var set = {};
        <br> var key = {};
        <br> set[25] = 'prashant';
        <br> set[key] = 5;
        <br>
        <br> console.log(set['25']); // prashant
        </br> console.log(set[key]); // 5
    </p>
    <p>-- Here the object internally converts the numeric 25 and key to string '25' because object parameters must be
        string, Thus we cannot use both of them simultaneously.</p>

    <!-- After ES6 -->
    <p>-- <u>After ES6</u> :
        <br>
        <br> With introduction of Set and WeakSet in ES6 we don't have to worry about the workaround limitations.
        <br>let set = new Set([!iterable]);
        <br> if an iterable object like Array is passed then all its items will be added to the set.
        <br>
        <br> let set = new Set();
        <br> set.add(25);
        <br> set.add('25');
        <br>
        <br> let set2 = new Set([1, 2, 3, 4, 5, 6, 7, 8]);
        <br> let set3 = new Set('Prashant');
        <br>
        <br> console.log(set.size); // 2
        <br> console.log(set2.size); // 8
        <br> console.log(set3.size); // 7 ['P', 'r', 'a', 's', 'h', 'n', 't'];
    </p>
    <p>-- Sets do not convert the values while checking (Except for +0 and -0).</p>
    <p>let set = new Set();
        <br> let key = {};
        <br> let key2 = {};
        <br> set.add(key);
        <br> set.add(key2);
        <br>
        <br> console.log(set.size) // 2
    </p>

    <!-- Sets Properties -->
    • <strong>Sets Properties</strong>
    <p>-- Set.prototype.constructor <br>
        -- Set.prototype.size
    </p>

    <!-- Sets Methods -->
    • <strong>Sets Methods</strong>
    <p>-- Set.prototype.add(item)
        <br> -- Set.prototype.clear()
        <br> -- Set.prototype.delete(item)
        <br> -- Set.prototype.entries()
        <br> -- Set.prototype.foreach(callback, thisArg)
        <br> -- Set.prototype.has(item)
        <br> -- Set.prototype[@@iterator]()
        <br> -- Set.prototype.keys()
        <br> -- Set.prototype.values()
    </p>

    <!-- Iterating with javascript Set -->
    • <strong>Iterating with javascript Set</strong>
    <p>-- <u>Simple Iteration</u>
        <br>
        <br> let set = new Set();
        <br> set.add(1);
        <br> set.add(2);
        <br> set.add(3);
        <br> set.add(4);
        <br>
        <br> // foreach loop
        <br> set.forEach((e) => {console.log(e);});
        <br> // 1
        <br> // 2
        <br> // 3
        <br> // 4
        <br>
        <br> for of loop
        <br> for (let item of set) {console.log(item);}
        <br> // 1
        <br> // 2
        <br> // 3
        <br> // 4
    </p>

    <!-- Iterating objects of Set -->
    <p>-- <u>Iterating objects of Set</u>
        <br>
        <br> let set = new Set();
        <br> set.add(1);
        <br> set.add('prashant');
        <br> set.add({a: 1, b: 2, c:3, d:4});
        <br>
        <br> for (let item of set.keys()) {
        <br> console.log(item);
        <br> }
        <br> // 1
        <br> // prashant
        <br> // {a: 1, b: 2, c: 3, d: 4}
        <br>
        <br> for (let item of set.values()) {
        <br> console.log(item);
        <br> }
        <br> // 1
        <br> // prashant
        <br> // {a:1, b:2, c:3, d:4}
        <br>
        <br> for (let [key, value] of set.entries()) {
        <br> console.log(key, value);
        <br> }
        <br> // 1 1
        <br> // prashant prashant
        <br> // {a:1, b:2, c:3, d:4} {a:1, b:2, c:3, d:4}
        <br>
        <br> let set = new Set();
        <br> set.add(1);
        <br> set.add('prashant');
        <br> set.add({a:1, b:2, c:3, d:4});
        <br>
        <br> // using `.next()`
        <br>const iterator = set.values();
        <br>
        <br> console.log(iterator.next().value);
        <br> // 1
        <br>
        <br> console.log(iterator.next().value);
        <br> // prashant
        <br>
        <br> console.log(iterator.next().value);
        <br> // {a:1, b:2, c:3, d:4}
    </p>
    <hr>

    <!-- WeakSets -->
    <h2>WeakSets</h2>
    <p>• A WeakSet is same as the Set except it can only store objects.</p>
    <p>let user = {name: 'Prashant Yadav', age: 23};
        <br>const users = new WeakSet(user);
    </p>
    <hr>

    <!-- Difference between Sets and WeakSets -->
    <h2>Difference between Sets and WeakSets</h2>
    <p>• WeakSets can only store objects unlike the Sets.</p>
    <p>• The add() method throws error when non-object item is passed to the WeakSet.</p>
    <p>• The has() and delete() method returns false for non-object.</p>
    <p>• WeakSets are not Iterable.</p>
    <p>• They do not have size and foreach as well.</p>
    <p> let user = {name: 'Prashant Yadav', age: 23};
        <br> let user2 = {name: 'Prashant Yadav', age: 23};
        <br> let user3 = {name: 'Prashant Yadav', age: 23};
        <br>
        <br> const users = new WeakSet();
        <br> users.add(user);
        <br> users.add(user2);
        <br> users.add(user3);
        <br>
        <br> console.log(users.has(user2)); // true
        <br>
        <br> users.delete(user2);
        <br>
        <br> console.log(users.has(user2)); // false
    </p>
    <p>• The WeakSet cleans itself once the object is deleted or if there is no reference to the object.</p>
    <p> console.log(users);
        <br> user3 = null;
        <br> console.log(users);
        <br> // WeakSet {{...}, {...}}
        <br>
        <br> // Wait for few seconds
        <br> console.log(users);
        <br> // WeakSet {{...}}
        <br> // it automatically garbage collect the object.
    </p>
    <hr>

    <!-- JavaScript Map -->
    <h2>JavaScript Map</h2>
    <p>• Before ES6 in order to store the key value pair we had to use objects. We never had any extra data structure
        except for an array.</p>
    <p>• With the introduction of JavaScript Map and Set, we have somethig extra to handle the data.</p>
    <p>• Just like Sets, Maps are also used to store the unique values except here it is key value pair.</p>

    <!-- Before ES6 -->
    <p>• <u><strong>Before ES6</strong></u>
        <br> -- Prior to the introduction of javascript Map, developers used to have a workaround to handle the key
        value pair but there was limitations to that workaround. Let us see the workaround first to see why there was
        need for the Maps :
        <br>
        <br> var map = {};
        <br> map.foo = "bar";
        <br>
        <br> // retrieving a value
        <br> let value = map.foo;
        <br> console.log(value);
    </p>
    <p>-- This approach works fine but if the situation gets more complex, then we run into the limitations of the
        object properties.
        <br>
        <br> var map = {};
        <br> map[5] = "bar";
        <br> console.log(map["5"]);
    </p>
    <p>-- Object internally converts anything to string to store the values. So the numeric 5 is converted to "5". Thus
        we cannot use numeric key. The same happens when we use objects as the key.
        <br>
        <br> var map = {};
        <br> var key = {};
        <br> var key2 = {};
        <br> map[key] = "prashant";
        <br> console.log(map[key2]); // prashant
    </p>
    <p>-- It converts object to string.</p>
    <p>-- Maps with falsy key were also difficult to handle.
        <br>
        <br> var map = {};
        <br> map.foo = false;
        <br> // checking for the existence of "foo" or a nonzero value?
        <br> if (map.foo) {
        // ...
        }
    </p>
    <p>-- Here we want to check if value is present inside the key foo but the falsy is automatically converted to the
        false. <strong>Note :</strong> we could use in operator, but that still check in the prototype of the objects,
        which make it only safe to use when an object has a null prototype.</p>

    <!-- After ES6 -->
    <p>• <u><strong>After ES6</strong></u>
        <br> -- Maps are ordered list of key value pair when key as well as value can be of any type.
        <br>
        <br> let map = new Map([iterable]);
        <br>
        <br> -- If an iterable object like Array (arrays with two elements, eg. [[1, 'one'],[2, 'two']]) whose
        elements
        are key-value pairs is passed then all its items will be added to the Map.
        <br> -- null values are treated as undefined.
        <br>
        <br> let map = new Map();
        <br> map.set(5, 'prashant');
        <br> map.set('5', 'yadav');
        <br> console.log(map.size); // 2
        <br> console.log(map.get(5)); // 'prashant'
        <br> console.log(map.get('5')); // 'yadav'
        <br>
        <br> let map2 = new Map([["name", "prashant"], ["age",, 23]]);
        <br> console.log(map2.size); // 2
        <br> console.log(map2.get('name')); // prashant
        <br>
        <br> -- we can also use objects as the key.
        <br>
        <br> let map = new Map();
        <br> let key1 = {};
        <br> let key2 = {};
        <br> map.set(key1, 'prashant');
        <br> map.set(key2, 'yadav');
        <br> console.log(map.size); // 2
        <br> console.log(map.get(key1)); // 'prashant'
        <br> console.log(map.get(key2)); // 'yadav'
    </p>

    <!-- Map Properties -->
    <p>• <strong>Map Properties</strong></p>
    <p> -- Map.prototype.constructor
        <br> -- Map.prototype.size
    </p>

    <!-- Map Methods -->
    <p>• <strong>Map Methods</strong></p>
    <p> -- Map.prototype.set(key, value)
        <br> -- Map.prototype.clear()
        <br> -- Map.prototype.delete(key)
        <br> -- Map.prototype.entries()
        <br> -- Map.prototype.foreach(callback, thisArg)
        <br> -- Map.prototype.has(key)
        <br> -- Map.prototype.get(key)
        <br> -- Map.prototype.[@@iterator]()
        <br> -- Map.prototype.keys()
        <br> -- Map.prototype.delete(key)
        <br> -- Map.prototype.values()
    </p>

    <!-- Adding item to the javascript map -->
    <p>• <strong>Adding item to the javascript map</strong></p>
    <p>let map = new Map();
        <br> map.set(1, 'prashant');
        <br> map.set(2, 'anil');
        <br> map.set(3, 'taha');
        <br> map.set(4, 'ankit');
        <br> map.set(4, 'ankit'); // ignore the duplicate values
        <br> map.set('4', 'yadav');
        <br> map.set('fullname', 'My name is Prashant Yadav');
        <br> map.set(undefined, 20);
        <br> let key = {a : 0, b : 1};
        <br> map.set(key, '25');
        <br> let key2 = function() {};
        <br> map.set(key2, 27);
        <br> map.set(null, 23);
        <br> console.log(map.size); // 9
        <br> console.log(map);
        <br>
        <br> // Map(9) {1 => "prashant", 2 => "anil", 3 => "taha", 4 => "ankit", "4" => "yadav", …}
        <br> // size: (...)
        <br> // __proto__: Map
        <br> // [[Entries]]: Array(9)
        <br> // 0: {1 => "prashant"}
        <br> // 1: {2 => "anil"}
        <br> // 2: {3 => "taha"}
        <br> // 3: {4 => "ankit"}
        <br> // 4: {"4" => "yadav"}
        <br> // 5: {"fullname" => "My name is Prashant Yadav"}
        <br> // 6: {undefined => 20}
        <br> // 7: {Object => 25}
        <br> // 8: {null => 23}
        <br> // length: 9
    </p>

    <!-- Finding item in Map -->
    <p>• <strong>Finding item in Map</strong></p>
    <p>console.log(map.has(key)); // true
        <br> console.log(map.has(null)); // true
        <br> console.log(map.has(key2)); // true
        <br> console.log(map.has(0)); // false
        <br>
        <br> -- Always pass objects as keys by storing it in variables
        <br>
        <br> let key = {a:0, b: 1};
    </p>

    <!-- Getting the value of a given key -->
    <p>• <strong>Getting the value of a given key</strong></p>
    <p> console.log(map.get(key)); // 25
        <br> console.log(map.get(null)); // 23
        <br> console.log(map.get(0)); // undefined
    </p>

    <!-- Removing an item with the given key from the Map -->
    <p>• <strong>Removing an item with the given key from the Map</strong></p>
    <p> map.delete(key);
        <br> map.delete(null);
        <br>
        <br> console.log(map.has(key)); // false
        <br> console.log(map.has(null)); // false
    </p>

    <!-- Iterating with Maps -->
    <p>• <strong>Iterating with Maps</strong></p>
    <p> -- <u>Simple Iteration</u>
        <br> map.forEach((value, key, ownerMap) => {
        <br> console.log(key + " " + value);
        <br> console.log(ownerMap === map);
        <br> });
        <br>
        <br> // 1 prashant
        <br> // true
        <br>
        <br> // 2 anil
        <br> // true
        <br>
        <br> // 3 taha
        <br> // true
        <br>
        <br> // 4 ankit
        <br> // true
        <br>
        <br> // 4 yadav
        <br> // true
        <br>
        <br> // fullname My name is Prashant Yadav
        <br> // true
        <br>
        <br> // undefined 20
        <br> // true
        <br>
        <br> // [object Object] 25
        <br> // true
        <br>
        <br> // null 23
        <br> // true
        <br>
        <br> -- We have used => arrow function, ownerMap is passed as this which equals to the current object ownerMap
        === map that is why it is returning true.
    </p>

    <!-- Using for of loop -->
    <p>• <strong>Using for of loop</strong></p>
    <p> for(const [key, val] of map) {
        <br> console.log(key, val);
        <br> }
        <br>
        <br> // 1 "prashant"
        <br> // 2 "anil"
        <br> // 3 "taha"
        <br> // 4 "ankit"
        <br> // 4 yadav
        <br> // fullname My name is Prashant Yadav
        <br> // undefined 20
        <br> // {a : 0, b : 1} 25
        <br> // f () {} 27
        <br> // null 23
    </p>

    <!-- Using Map.prototype.keys() -->
    <p>• <strong>Using Map.prototype.keys()</strong></p>
    <p> for (var key of map.keys()) {
        <br> console.log(key);
        <br> }
        <br>
        <br> // 1
        <br> // 2
        <br> // 3
        <br> // 4
        <br> // '4'
        <br> // fullname
        <br> // undefined
        <br> // {a:0, b:1}
        <br> // f () {}
        <br> // null
    </p>

    <!-- Using Map.prototype.values() -->
    <p>• <strong>Using Map.prototype.values()</strong></p>
    <p> for (var key of map.values()) {
        <br> console.log(key);
        <br> }
        <br>
        <br> // prashant
        <br> // anil
        <br> // taha
        <br> // ankit
        <br> // yadav
        <br> // My name is Prashant Yadav
        <br> // 20
        <br> // 25
        <br> // 27
        <br> // 23
    </p>

    <!-- Using Map.prototype.entries() -->
    <p>• <strong>Using Map.prototype.entries()</strong></p>
    <p>-- We can destructure the value to access them separately.
        <br>
        <br> for (let[key,value] of map.entries()) {
        <br> console.log(key + " = " + value);
        <br> }
        <br>
        <br> // 1 = prashant
        <br> // 2 = anil
        <br> // 3 = taha
        <br> // 4 = ankit
        <br> // 4 = yadav
        <br> // fullname = My name is Prashant Yadav
        <br> // undefined = 20
        <br> // [object Object] = 25
        <br> // function() {} = 27
        <br> // null = 23
    </p>
    <hr>

    <!-- WeakMaps -->
    <h2>WeakMaps</h2>
    <p>• WeakMaps are to the maps what weakSets are to the sets. In weakMap every key must be object, inserting an
        non-object will result in error. Objects are held weakly so that if there is no reference to key then that value
        will be removed from the WeakMap or garbage collected.</p>
    <p>• Note : key should be objects, but value can be anything.</p>
    <p>• let key = {}, key2 = {};
        <br> let weakMap = new WeakMap([[key1, "prashant"],[key2, 23]]);
        <br> console.log(weakMap.has(key1)); // true
        <br> console.log(weakMap.get(key1)); // "prashant"
        <br> console.log(weakMap.has(key2)); // true
        <br> console.log(weakMap.get(key2)); // 23
    </p>
    <p>• The WeakMap cleans itself once the key is deleted or if there is no reference to the key.</p>
    <p> let dad = {name : "Daddy"};
        <br> let mom = {name : "Mommy"};
        <br>
        <br> let map = new Map();
        <br> let weakMap = new weakMap();
        <br>
        <br> map.set(dad, 1);
        <br> map.set(mom, 2);
        <br>
        <br> dad = null;
        <br> mom = null;
        <br>
        <br> map;
        <br> // map(1) {{...}}
        <br>
        <br> weakMap;
        <br> // Wait for few seconds
        <br> // WeakMap {}
        <br>
        <br> -- As we can see mom was garbade collected when we set its value to null while dad is still present.
    </p>
    <hr>

    <!-- Difference between Maps and WeakMaps -->
    <h2>Difference between Maps and WeakMaps</h2>
    <p>• Passing non-objects as key will result in error.</p>
    <p>• The has(key) and delete(key) method returns false for non-object.</p>
    <p>• They have only four methods has(key), delete(key), get(key), set(key, value).</p>
    <p>• WeakMaps are not iterable.</p>
    <p>• WeakMaps are very useful when creating objects related to particular DOM elements. That way when DOM element is
        no longer associated then it will automatically be garbage collected.</p>
    <hr>

    <!-- JavaScript Spread and Rest Operator -->
    <h2>JavaScript Spread and Rest Operator</h2>
    <p>• The ... is the spread syntax that allows you to specify an array that should be split and have its items passed
        in as seperate arguments to a function.</p>
    <p>• According to MDN - The spread syntax allows an iterable such as an array expression or string to be expanded in
        places where zero or more arguments (for function calls) or elements (for array literals) expected, or an object
        expression to be expanded in places where zero or more key-value pairs (for object literals) are expected.
        <br>
        <br> let arr = [1, 2, 3, 4, 5];
        <br>
        <br> function multiply(a, b, c, d, e) {
        <br> return a * b * c * d * e;
        <br> }
        <br>
        <br> // Spreads the array as seperate parameters
        <br> console.log(multiply(...arr)); // 120
        <br>
        <br> -- Consider a scenario where we have to find the largest number from the given array of numbers. The ideal
        solution will be to use Math.max with apply method.
        <br>
        <br> let arr = [1, 2, 3, 4, 5];
        <br> console.log(Math.max.apply(null, arr)); // 5
        <br>
        <br>-- The solution works perfectly but it is bit confusing, ES6 ... spread operator makes this very easy and
        simple.
        <br>
        <br> let arr = [1, 2, 3, 4, 5];
        <br> console.log(Math.max(...arr)); // 5
        <br>
        <br> JavaScript engine spills arr into individual arguments.
    </p>

    <!-- Combining multiple arrays -->
    <p>• <u><strong>Combining multiple arrays</strong></u></p>
    <p>-- With javascript ... spread operator it is easy to combine multiple arrays.
        <br>
        <br> let arr = [1, 2, 3, 4, 5];
        <br> let arr2 = [6, 7, 8, 9, 10];
        <br>
        <br> let combine = [...arr, ...arr2];
        <br> console.log(combine);
        <br> // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
        <br>
        <br> let combine2 = [0, ...arr, 11, ...arr2, 12];
        <br> console.log(combine2);
        <br> // [0, 1, 2, 3, 4, 5, 11, 6, 7, 8, 9, 10, 12]
        <br>
        <br> let combine3 = [...arr, 'prashant', ...arr2];
        <br> console.log(combine3);
        <br> // [1, 2, 3, 4, 5, 'prashant', 6, 7, 8, 9, 10]
        <br>
        <br> The ... spread operator allows us to pass all the items of arr and arr2 at the same time add extra items
        also.
    </p>

    <!-- Copying an array -->
    <p>• <u><strong>Copying an array</strong></u></p>
    <p>-- Drawbacks while copying arrays before ... spread operators.
        <br>
        <br> let arr = [1, 2, 3, 4, 5];
        <br> let copy = arr;
        <br> console.log(copy);
        <br> // [1, 2, 3, 4, 5]
        <br>
        <br> arr.push(6);
        <br> console.log(arr);
        <br> // [1, 2, 3, 4, 5, 6]
        <br>
        <br> console.log(copy);
        <br> // [1, 2, 3, 4, 5, 6]
        <br>
        <br> -- We have added an extra item to arr with arr.push(6) but the same gets update in copy, this happens
        because arr is never copied to copy but passed as the reference which means copy is just pointing to arr. A
        seperate solution would be to copy all the items individually using loops.
        <br> -- We can solve this issue using javascript ... spread operator.
        <br>
        <br> let arr = [1, 2, 3, 4, 5];
        <br> let copy = [...arr];
        <br> console.log(copy);
        <br> // [1, 2, 3, 4, 5]
        <br>
        <br> arr.push(6);
        <br> console.log(arr);
        <br> // [1, 2, 3, 4, 5, 6]
        <br>
        <br> console.log(copy);
        <br> // [1, 2, 3, 4, 5]
    </p>

    <!-- Use with Constructors -->
    <p>• <u><strong>Use with Constructors</strong></u></p>
    <p>-- It is not possible to directly use an array and apply with new keyword while declaring constructor. But with
        the javascript ... spread operators we can do this easily.
        <br>
        <br> let dateFields = [1970, 0, 1];
        <br> let d = new Date(...dateFields);
        <br> console.log(d);
        <br> // Thu Jan 01 1970 00:00:00 GMT+0530 (Indian Standard Time)
    </p>

    <!-- Use with Functions -->
    <p>• <u><strong>Use with Functions</strong></u></p>
    <p>-- With the introduction of ... spread operators in ES6 we can now replace the apply() method to pass the arrays
        of arguments to functions.
        <br>
        <br> let example = (a, b, c, d = 1) {
        <br> return a * b * c * d;
        <br> }
        <br> let arr = [1, 2, 3, 4, 5];
        <br>
        <br> // Before ... spread operators
        <br> console.log(example.apply(null, arr)); // 24
        <br>
        <br> // After ... spread operators
        <br> console.log(example(...arr)); // 24
        <br>
        <br> -- Array is split into the parameters and automatically passed by the javascript engine. Extra parameters
        are ignored.
    </p>
    <hr>

    <!-- Rest Parameters -->
    <h2>Rest Parameters</h2>
    <p>• Rest parametes are exactly opposite of spread operator. Spread operator is used to expand all the items of the
        arrays while rest parameters is used to condense different items to form an array. Rest parameters are also
        indicated with ... in javascript.
        <br>
        <br> let arr = [1, 2, 3, 4, 5, 6, 7, 8];
        <br> const [first, second, ...remaining] = arr;
        <br> console.log(first);
        <br> // 1
        <br> console.log(second);
        <br> // 2
        <br> console.log(remaining);
        <br> // [3, 4, 5, 6, 7, 8]
        <br>
        <br> -- The destructuring removed the first and second item and added the remaining items to the rest parameters
        ...remaining
    </p>

    <!-- Rest parameters with Functions -->
    <p>• Rest parameters with Functions</p>
    <p> -- The rest parameters are ideally used with functions instead of arguments object as it has many limitations.
        <br>
        <br> let addAll = (...args) => {
        <br> return args.reduce((a, b) => {return a + b});
        <br> }
        <br>
        <br> console.log(addAll(1, 2, 3, 4, 5, 6, 7, 8, 9, 10));
        <br> // 55
    </p>
    <hr>

    <!-- Difference between arguments and Rest parameters -->
    <h2>Difference between arguments and Rest parameters</h2>
    <p>-- arguments objects are not real arrays they are just array like objects which have only one property length,
        where as rest parameters are real arrays which has all methods like pop, forEach, push etc.</p>
    <p>-- For arguments objects we cannot use different names while with the rest parameters we can use our custom
        names.</p>
    <p>function multiply(d, ...everything){
        <br> return everything.map(e => d * e);
        <br> }
        <br>
        <br> console.log(multiply(2, 1, 2, 3, 4, 5, 6, 7, 8));
        <br> // [2, 4, 6, 8, 10, 12, 14, 16]
    </p>
    <hr>

    <!-- JavaScript destructuring -->
    <h2>JavaScript destructuring</h2>
    <p>• Arrays and Objects are the heart of the javascript and we use it so much while programming. But still, even if
        we want only a few value or property from either of them we have to call them entirely. In order to make this
        simple ES6 introduced destructuring in javascript.</p>
    <p>• According to MDN - <br>
        The destructuring assignment syntax is a JavaScript expression that makes it possible to unpack value from
        arrays or properties from objects, into distinct variables.</p>

    <!-- Before ES6< -->
    <p>• <strong><u>Before ES6</u></strong>
        <br>
        <br> -- In order to access the properties of objects we had to call them like this.
        <br>
        <br> var person = {
        <br> name : 'prashant yadav',
        <br> age : 23,
        <br> role : Software Engineer
        <br> }
        <br>
        <br> var name = person.name;
        <br> var age = person.age;
        <br> var role = person.role;
        <br> console.log(name, age, role);
        <br> // prashant yadav 23 Software Engineer
    </p>

    <!-- After ES6 -->
    <p>• <strong><u>After ES6</u></strong>
        <br>
        <br> -- Now with the destructuring we have much simple syntax to access the properties of objects.
        <br> -- Object destructuring uses object literals syntax {}
        <br>
        <br> var person = {
        <br> name : 'prashant yadav',
        <br> age : 23,
        <br> role : Software Engineer
        <br> }
        <br>
        <br> let {name, age} = person;
        <br> console.log(name, age);
        <br> // prashant yadav 23
        <br>
        <br> let {name, age, role} = person;
        <br> console.log(name, age, role);
        <br> // prashant yadav 23 Software Engineer
        <br>
        <br> let {name, role} = person;
        <br> console.log(name, role);
        <br> // prashant yadav software engineer
        <br>
        <br> -- We can now access any property from the object and assign it to the variable, Here the variable name and
        the property name is same so we are just destructuring it.
        <br> -- let {role} = person; Removes the person.role and assign it the variable name role.
        <br> -- If we want to use a different variable name then we can do it like below.
        <br>
        <br> let {name : fullname, age : completeAge, role : designation} = person;
        <br>
        <br> console.log(fullname, completeAge, desgination);
        <br> // prashant yadav 23 Software Engineer
        <br>
        <br> -- let {name : fullName} pulls the person.name property and assign it to the fullname variable.
        <br> -- Default values can also be assigned to the variables.
        <br>
        <br> let person = {
        <br> name : 'prashant yadav',
        <br> age : 23
        <br> }
        <br> let {name : fullName, age : completeAge, role : designation = 'Engineer'} = person;
        <br>
        <br> console.log(fullName, completeAge, designation);
        <br> // prashant yadav 23 Engineer
    </p>

    <!-- Nested objects destructuring -->
    <p>• <strong>Nested objects destructuring</strong></p>
    <p>-- We can also use the destructuring for nested objects.
        <br>
        <br> let person {
        <br> name : 'prashant yadav',
        <br> age : 23,
        <br> address : {
        <br> street : 'random',
        <br> city : 'mumbai',
        <br> pincode : 421209
        <br> }
        <br> }
        <br>
        <br> let {address : {street, city}} = person;
        <br> console.log(street, city);
        <br> // random mumbai
        <br>
        <br> -- Custom variables with nested objects destructuring.
        <br>
        <br> let {address : {street : completeStreet, city : completeCity}} = person;
        <br> console.log(completeStreet, completeCity);
        <br> // random mumbai
    </p>
    <hr>

    <!-- Array Destructuring -->
    <h2>Array Destructuring</h2>

    <!-- Before ES6 -->
    <p>• <strong><u>Before ES6</u></strong>
        <br>
        <br> var arr = ['prashant', 23, 'engineer', 'javascript'];
        <br> var first = arr[0];
        <br> var second = arr[1];
        <br> console.log(first, second);
        <br> // prashant 23
    </p>

    <!-- After ES6 -->
    <p>• <strong><u>After ES6</u></strong>
        <br>
        <br> -- Array destructuring is similar to the object destructuring but it uses array literals syntax [].
        <br>
        <br> let arr = ['prashant', 23, 'engineer', 'javascript'];
        <br> let [first, second] = arr;
        <br> console.log(first, second);
        <br> // prashant 23
        <br>
        <br> -- If you want to skip and access values at other positions then we can do so by keeping that position
        blank.
        <br>
        <br> let [first, second] = arr;
        <br> console.log(first, , third);
        <br> // prashant engineer
        <br>
        <br> -- We have kept the seconds position blank.
        <br>
        <br> -- We can also assign default values to the variables.
        <br>
        <br> let [, second, , fourth, fifth = 'default value'] = arr;
        <br> console.log(second, fourth, fifth);
        <br> // 23 javascript default value
        <br>
        <br> -- We can also use ... spread operator to copy all the remaining array values in any variable.
        <br>
        <br> let [first, ...remaining] = arr;
        <br> console.log(first, remaining);
        <br> // prashant [23, 'engineer', 'javascript']
    </p>
    <hr>

    <!-- Nested Array Destructuring -->
    <h2>Nested Array Destructuring</h2>
    <p>• It is also possible to do nested array destructuring.</p>
    <p> let arr = ['prashant', 23, 'engineer', ['random', 'mumbai', 421209]];
        <br> let [first,,, [, city, zip, state = 'Maharashtra']] = arr;
        <br> console.log(first, city, zip, state);
        <br> // prashant mumbai 421209 Maharashtra
    </p>
    <hr>

    <!-- Swapping with Array destructuring -->
    <h2>Swapping with Array destructuring</h2>
    <p>• We can swap values very easily with an array destructuring.</p>
    <p>let first = 1;
        <br> let second = 2;
        <br> console.log(first, second);
        <br> // 1 2
        <br>
        <br> // Swap
        <br> [first, second] = [second, first];
        <br>
        <br> console.log(first, second);
        <br> // 2 1
    </p>
    <hr>

    <!-- Cloning an array with destructuring -->
    <h2>Cloning an array with destructuring</h2>
    <p>let arr = [2, 3, 5, 6]
        <br> let [ ...cloned ] = arr;
        <br> console.log(cloned);
        <br> [2, 3, 5, 6]
    </p>
    <hr>

    <!-- Mixed destructuring in javascript -->
    <h2>Mixed destructuring in javascript</h2>
    <p>• We can use array and object destructuring simultaneously.</p>
    <p>let person = {
        <br> name : 'prashant yadav',
        <br> age : 23,
        <br> address : {
        <br> street : 'random',
        <br> city : 'mumbai',
        <br> pincode : 421209
        <br> },
        <br> phone : [112124124124, 23124124124, 125151241212]
        <br> };
        <br>
        <br> let {
        <br> name,
        <br> address : {street : streetAddress},
        <br> phone : [first]
        <br> } = person;
        <br>
        <br> console.log(name, streetAddress, first);
        <br> // prashant yadav random 112124124124
    </p>
    <hr>

    <!-- Destructuring with Functions -->
    <h2>Destructuring with Functions</h2>
    <p>• We can use destructuring with parameters passed to the functions.</p>
    <p>let person = {
        <br> name : 'prashant yadav',
        <br> age : 23,
        <br> address : {
        <br> street : 'random',
        <br> city : 'mumbai',
        <br> pincode : 421209
        <br> },
        <br> phone : [112124124124, 23124124124, 125151241212]
        <br> };
        <br>
        <br> let showDetails = ({name, age}) => {
        <br> console.log(`${name} is ${age} years old`);
        <br> };
        <br>
        <br> showDetails(person);
        <br> // prashant yadav is 23 years old
    </p>
    <hr>

    <!-- Introduction to ES6 class -->
    <h2>Introduction to ES6 class</h2>
    <p>• As you might already know javascript is a prototype-based language. It was not designed to object-oriented but
        as the javascript was getting popular there were different libraries which were trying to extend javascript to
        be class based. So ES6 introduced class in javascript.</p>
    <p>• According to MDN - classes are primarily syntactically sugar ove js's existing prototype-based inheritance. The
        class syntax does not introduce a new object-oriented inheritance model to JavaScript.</p>
    <p>• Before diving deep into the javascript class, let us first see how different object-oriented concepts were
        handles through the prototype.</p>

    <!-- Before ES6 -->
    <p>• <strong><u>Before ES6</u></strong></p>
    <p>-- Functions were used to replicate class.
        <br> -- Declaring properties
        <br>
        <br> // Creating new functions
        <br> function individual(name, age) {
        <br> this.name = name;
        <br> this.age = age;
        <br> }
        <br>
        <br> -- <u>Calling the function as class</u>
        <br>
        <br> let person1 = new individual('prashant', 23);
        <br> let person2 = new individual('yogesh', 23);
        <br>
        <br> -- <u>Declaring Methods</u>
        <br>
        <br> // By declaring method inside the function
        <br> function individual(name, age) {
        <br> this.name = name;
        <br> this.age = age;
        <br> this.details = function() {
        <br> return this.name + ' is ' + this.age + ' years old.';
        <br> }
        <br> }
        <br>
        <br> // By declaring the method through prototype
        <br> individual.prototype.details = function() {
        <br> return this.name + ' is ' + this.age + ' years old.';
        <br> };
        <br>
        <br> // Calling the function
        <br> let person1 = new individual('prashant', 23);
        <br> console.log(person1);
        <br>
        <br> // "prashant is 23 years old."
    </p>

    <!-- After ES6 -->
    <p>• <strong><u>After ES6</u></strong></p>
    <p>-- There are two ways of declaring a class.
        <br>
        <br> 1) Class declarations
        <br> 2) Class expressions
    </p>
    <p>1-- <u>Class Declarations</u>
        <br>
        <br> // declaring class
        <br> class Individual {
        <br>
        <br> // declaring properties inside constructor
        <br> constructor(name, age) {
        <br> this.name = name;
        <br> this.age = age;
        <br> }
        <br>
        <br> // declaring display method
        <br> details() {
        <br> return `${this.name} is ${this.age} years old.`;
        <br> }
        <br> }
        <br>
        <br> // creating a person object from individual class
        <br> let person = new Individual('prashant', 23);
        <br>
        <br> // calling the display method
        <br> console.log(person.details());
        <br> // "prashant is 23 years old."
    </p>
    <p>2-- <u>Class Expression</u>
        <br>
        <br> We can assign the class expression to the variables.
        <br> •• Un-named class expressions
        <br> •• Named class expressions
        <br>
        <br> •• // UN-NAMED class expressions
        <br> const person = class {
        <br>
        <br> // declaring properties inside constructor
        <br> constructor(name, age) {
        <br> this.name = name;
        <br> this.age = age;
        <br> }
        <br>
        <br> // declaring display methods
        <br> display() {
        <br> return `${this.name} is ${this.age} years old.`;
        <br> }
        <br> }
        <br>
        <br> •• // NAMED class expressions
        <br> const Person = class Individual {
        <br>
        <br> // declaring properties inside constructor
        <br> constructor(name, age) {
        <br> this.name = name;
        <br> this.age = age;
        <br> }
        <br>
        <br> // declaring display method
        <br> details() {
        <br> return `${this.name} is ${this.age} years old.`;
        <br> }
        <br> }
        <br>
        <br> // creating a person object from individual class members
        <br> let person1 = new Person('prashant', 23);
        <br>
        <br> // calling the display method
        <br> console.log(person1,details());
        <br> // "prashant is 23 years old."
    </p>
    <p> -- constructor() should be declared only once.</p>
    <p> -- As we can see class works similar to the prototype based approach. But there are many advantages of using
        classes.</p>
    <p> -- Unlike functions, class declarations are not hoisted, which means variables declared inside are not
        accessible outside. They remain in temporal dead zone just like let until execution reaches the declaration.</p>
    <p> -- Code inside class runs in strict mode.</p>
    <p> -- Methods declared inside class are non-enumerable. Unlike prototype based where we had to use
        object.defineProperty() to make method non-enumerable.</p>
    <p> -- Calling the class constructor without new keyword will throw error. Also all the methods declared inside
        class lack the [[construct]] method and calling them with new keyword will result in error.</p>
    <p> -- Declaring the method name same as class name inside class will result in error.</p>

    <!-- Static methods -->
    <p>• <strong><u>Static methods</u></strong></p>
    <p> -- Static methods are only accessible by parents (class), derived child or instance of the class cannot access
        them.
        <br>
        <br> class Person{
        <br>
        <br> // declaring properties
        <br> constructor(name, age) {
        <br> this.name = name;
        <br> this.age = age;
        <br> }
        <br>
        <br> // declaring method
        <br> // accessible by all
        <br> details() {
        <br> console.log(`${this.name} is ${this.age} years old.`);
        <br> }
        <br>
        <br> // static method
        <br> // accessible only by parent
        <br> static display() {
        <br> console.log(`I am only accessible by parent.`);
        <br> }
        <br> }
        <br>
        <br> INPUT :
        <br> let person1 = new Person('prashant', 23);
        <br> person1.details();
        <br> Person.display();
        <br> person1.display();
        <br>
        <br> OUTPUT :
        <br> "prashant is 23 years old."
        <br> "I am only accessible by parent."
        <br> Uncaught TypeError : person1.display is not a function
    </p>

    <!-- Accessor Properties -->
    <p>• <strong><u>Accessor Properties</u></strong></p>
    <p> -- There are two accessor properties which we can use with class :
        <br> 1) Set :- To set the value of any property.
        <br> 2) Get :- To get the value of any property.
    </p>
    <p> class Person {
        <br>
        <br> // declaring properties
        <br> constructor(name, age) {
        <br> this.name = name;
        <br> this.age = age;
        <br> }
        <br>
        <br> // Set name
        <br> set nickName(name) {
        <br> this.name = name;
        <br> }
        <br>
        <br> // Get Name
        <br> get nickName() {
        return `your name is ${this.name}`;
        <br> }
        <br> }
        <br>
        <br> INPUT :
        <br> let person1 = new Person1('Prashant Yadav', 23);
        <br> console.log(person1.nickName);
        <br> // set the new nickName
        <br> person1.nickName = "Golu";
        <br> console.log(person1.nickName);
        <br>
        <br> OUTPUT :
        <br> "your name is Prashant Yadav"
        <br> "your name is Golu"
    </p>

    <!-- Computed method names -->
    <p>• <strong><u>Computed method names</u></strong></p>
    <p> -- Class methods and Accessor properties can computed names, that means their name can be provided at runtime.
        <br>
        <br> let myMethod = 'displayDetail';
        <br>
        <br> class Person {
        <br>
        <br> // declaring properties
        <br> constructor(name, age) {
        <br> this.name = name;
        <br> this.age = age;
        <br> }
        <br>
        <br> // declaring a method with the computed name
        <br> [myMethod]() {
        <br> return `${this.name} is ${this.age} years old.`;
        <br> }
        <br> }
        <br>
        <br> INPUT :
        <br> let person = new Person('Prashant Yadav', 23);
        <br> console.log(person.displayDetail());
        <br>
        <br> OUTPUT :
        <br> "Prashant Yadav is 23 years old."
    </p>
    <p> -- Accessor properties can also use computed methods.
        <br>
        <br> let myMethod = 'differentName';
        <br> class Person() {
        <br>
        <br> // declaring properties
        <br> constructor(name, age) {
        <br> this.name = name;
        <br> this.age = age;
        <br> }
        <br>
        <br> // Set name
        <br> set [myMethod](name) {
        <br> this.name = name;
        <br> }
        <br>
        <br> // get name
        <br> get [myMethod]() {
        <br> return `your name is ${this.name}`
        <br> }
        <br> }
        <br>
        <br> INPUT :
        <br> let person1 = new Person('Prashant Yadav', 23);
        <br> console.log(person1.differentName);
        <br>
        <br> // set the new differentName
        <br> person1.differentName = "Golu";
        <br> console.log(person1.differentName);
        <br>
        <br> OUTPUT :
        <br> "your name is Prashant Yadav"
        <br> "your name is Golu"
    </p>

    <!-- Inheritance -->
    <p>• <strong><u>Inheritance</u></strong></p>
    <p> -- Before ES6, implementing inheritance was a tedious process with prototype. Proper inheritance required
        multiple steps.</p>
    <p> function Rectangle(width, height) {
        <br> this.width = width;
        <br> this.height = height;
        <br> }
        <br>
        <br> // declaring method to calculate area;
        <br> Rectangle.prototype.getArea = function() {
        <br> return this.height * this.width;
        <br> }
        <br>
        <br> // Extending rectangle to use it as square
        <br> // using call, apply, bind
        <br> function Square(length) {
        <br> Rectangle.call(this, length, length);
        <br> }
        <br>
        <br> // Extending Methods
        <br> Square.prototype = Object.create(Rectangle.prototype, {
        <br> constructor: {
        <br> value: Square,
        <br> enumerable: true;
        <br> writable: true,
        <br> configurable: true
        <br> }
        <br> });
    </p>
    <p> var square = new Square(3);
        <br>
        <br> console.log(square.getArea()); // 9
        <br> console.log(square instanceof Square); // true
        <br> console.log(square instanceof Rectangle); // true
    </p>
    <p> -- After ES6, we can use extends keyword to achieve the inheritance.</p>
    <p> // Declaring the rectangle class
        <br> class Rectangle {
        <br> // initialize the properties
        <br> constructor(length, width) {
        <br> this.length = length;
        <br> this.width = width;
        <br> }
        <br>
        <br> // Method to calculate the area
        <br> getArea() {
        <br> return this.length * this.width;
        <br> }
        <br> }
        <br>
        <br> // Extend the Square to use Rectangle
        <br> class Square extends Rectangle {
        <br> constructor(length) {
        <br>
        <br> // same as Rectangle.call(this, length,, length)
        <br> super(length, length);
        <br> }
        <br> }
    </p>
    <p> const square = new Square(3);
        <br>
        <br> console.log(square.getArea()); // 9
        <br> console.log(square instanceof Square); // true
        <br> console.log(square instanceof Rectangle); // true
    </p>
    <p> -- Points to remember while inheriting the another class.
        <br> > If you inherit any class and declare the constructor() method inside it, you must declare super() method
        as well inside the constructor(). Failing to do so will result in error.
        <br> > If there are any static methods in the parent class then they are also accessible to the inherited class.
        <br> > new.target can be used to check the current instance of the class and where it is getting called from.
    </p>

    <!-- Derived class form expression -->
    <p>• <strong><u>Derived class form expression</u></strong></p>
    <p> -- One of the most powerful features of ES6 class is the ability to derive from a class from an expression.</p>
    <p> -- You can use extends with any expression as long as the expression resolves to a function with [[Construct]]
        and a prototype.</p>
    <p> // A function declaration
        <br> function Rectangle(length, width) {
        <br> this.length = length;
        <br> this.width = width;
        <br> }
        <br>
        <br> // Adding method to the function
        <br> Rectangle.prototype.constructor = function() {
        <br> return this.length * this.width;
        <br> };
        <br>
        <br> // Extending the rectangle function
        <br> class Square extends Rectangle {
        <br> constructor(length) {
        <br> super(length, length);
        <br> }
        <br> }
    </p>
    <p> INPUT :
        <br> let x = new Square(3);
        <br> console.log(x.getArea()); // 9
        <br> console.log(x instanceof Rectangle); // true
    </p>
    <p> -- With this powerful feature, we can inherit the inbuilt functions as well. The only clause is that they should
        have [[construct]] method and a prototype.</p>

    <!-- Extending the Array -->
    <p>• <strong><u>Extending the Array</u></strong></p>
    <p> class MyArray extends Array {
        <br> // empty
        <br> }
        <br>
        <br> var colors = new MyArray();
        <br> colors[0] = "red";
        <br> console.log(colors.length); // 1
        <br>
        <br> colors.length = 0;
        <br> console.log(colors[0]); // undefined
    </p>
    <hr>

    <script src="script.js" async defer></script>
</body>

</html>