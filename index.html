<!DOCTYPE html>

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>Learner's Bucket</title>
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="">
</head>

<body>
    <!-- Var, Let and Const in JavaScript -->
    <h2>Var, Let and Const in JavaScript</h2>
    <!-- Var in javascript -->
    <p>• Var in javascript are function scoped, which means they are accessible outside the block scope
        even though we have declared them inside it.</p>
    <!-- Hoisting -->
    <p>• This happends because of Hoisting.</p>
    <p>var are treated as if they are at the top of the function (or global scope) regardless of where
        the actual declaration occurs, this is called hoisting.</p>
    <!-- Let in javascript -->
    <p>• Let are declared same as var but it limits the variable scope to the given block. That is why
        we should declare at the top of the block so that is accessible throughout the block and its
        sub-blocks.</p>
    <!-- Const in javascript -->
    <p>• Like let const is also block scoped. But it differs from the fact that their variable cannot
        be redeclared or change by re-assigning the value. The value remains Constant.</p>
    <hr>

    <!-- What is Temporal Dead Zone ? -->
    <h2>What is Temporal Dead Zone?</h2>
    <p>• Temporal Dead Zone is the time since when the let variable was hoisted and till it is intialized some
        value,
        the time between that is known as the Temporal Dead Zone.</p>
    <p>• So whenever you try to access a variable inside the temporal dead zone, it gives you a ReferenceError.</p>
    <p>• When the variable is inside this temporal dead zone you cannot access them and they can only be accessed
        once
        some value is initialized to them.</p>
    <p>• The let and const variables are not accessible before they are initialized with some value, and the phase
        between the starting of the execution of block in which the let or const variable is declared till that
        variable
        is being initialized is called Temporal Dead Zone for the variable.</p>
    <hr>

    <!-- Transpiler -->
    <h2>Transpiler</h2>
    <p>• If you want old or older versions of browsers to understand new features, one must use a
        transpiler.</p>
    <p>• A transpiler converts the new JavaScript code to a browser compatible javascript.</p>
    <p>• That is why babel is created.</p>
    <p>• Babel is a JavaScript compiler which converts the new Javascript to a browser compatible
        Javascript.</p>
    <hr>

    <!-- How to use Babel? -->
    <h2>How to use Babel?</h2>
    <p>• Copy the Babel cdn from babel cdn website and import this in your website.</p>
    <p>• Now after importing the cdn, we need to tell the browser that the current script which we
        are writing is in Babel.</p>
    <p>• We can do that by setting the type of the script tag.</p>
    <!-- <script type = "text/babel">
            let n = [1, 2, 3];
            let squares = n.map((e) => e * e);
        </script> -->
    <hr>

    <!-- What is the difference between Polyfilling and Transpiling? -->
    <h2>What is the difference between Polyfilling and Transpiling?</h2>
    <p>• A polyfill tries to emulate specific methods, so you can use them as if they were already
        supported by the browser (or node engine), on the other hand, A transpiler will modify your
        code and replace code by other code that does the same, which can then be executed in old
        browsers.</p>
    <p>• So you can use a polyfill if your target browser did not implement the feature you need
        to use. A transpiler, on the other hand, is more complex and will let you use the new
        language syntax and transforming your source code.</p>
    <p>• In short, a polyfill will change the code in your target browser if some of the new features
        you wanted to add are not working.</p>
    <p>• And transpiler will let us use the new code of the new features which we wanted to add,
        but will transform or convert it into the new source code first.</p>
    <hr>

    <!-- What are Template Strings -->
    <h2>What are Template Strings</h2>
    <p>• Template Literals are strings which allow embedded expressions. Before ES6 introduced them, they were
        called as Template Strings.</p>
    <p>• JavaScript strings always had limitations compared to the strings of the other programming languages. Apart
        from simple concatenation, there was not much we could have done with strings.</p>
    <p>• ECMAScript 6's template literals provided syntax for creating domain-specific languages (DSLs) for working
        with
        content in a safer way than the solutions available earlier.</p>
    <p>• With template strings we can handle following features easily : <br>
        -- Multiline Strings <br>
        -- Basic string formatting <br>
        -- HTML Escaping </p>
    <p>• Against the standard ' ' and " " quotes template literals uses back-ticks ` `.</p>
    <hr>

    <!-- JavaScript Fat Arrow Function -->
    <h2>JavaScript Fat Arrow Function</h2>
    <p>• One of the most interesting parts of ES6 is arrow functions. Arrow functions as it sounds is the new syntax =>
        of declaring a function. But it behaves differently from the traditional functions of JavaScript.</p>
    <p>-- No this, arguments, super or new.target bindings of its own. <br>
        -- We cannot use them as Constructors. <br>
        -- They do not have prototype property. <br>
        -- yield keyword cannot be used (Until in special cases). <br>
        -- Unique named parameters.</p>
    <p>• When to avoid using arrow functions in JavaScript : <br>
        -- If we want to access the this of the current function then it is better to avoid the arrow functions. <br>
        -- Also if you want to access all the arguments of the function then it is better to avoid arrow functions as
        arguments are missing or use rest operators.</p>
    <hr>

    <!-- Functions with default parameters in JavaScript -->
    <h2>Functions with default parameters in JavaScript</h2>
    <p>• Functions are really amazing in javascript as they allow to pass any numbers of parameters regardless of the
        numbers of parameters declared. Thus there is a need to handle function with default parameters.</p>
    <p>• Before exploring the default parameters of ES6, let us see how to handle it in older versions of javascript :
    </p>
    <p>•<strong> Before ES6 :</strong> <br>
        -- In javascript the function parameters were default to undefined. To handle them we had to check the
        parameters and assign values if they were undefined. <br>
        -- If we have not checked and assigned the value for by then it would have returned NaN. <br>
        -- While this approach is good but imagine we have more parameters and we have to check for every parameters and
        assign value to it. It will get quite lengthy. </p>
    <p>•<strong> After ES6 :</strong> <br>
        -- With default parameters introduction in ES6 we can now assign the default values in the function head itself.
        <br>
        -- The default value is assigned only to the undefined parameters not to the other falsy values.</p>
    <p>•<strong> Passing Functions, Arrays and Objects : </strong> <br>
        -- We could also set default parameters to be function, arrays and objects in javascript. <br>
        -- We can also set the existing parameters as the default value. <br>
        -- Default values are evaluated at call time. <br> </p>
    <p>•<strong> Destructured values with default parameters :</strong> <br>
        -- We can set the default parameters with destructuring. <br>
        -- We will use arrow (=>) function for it.</p>
    <hr>

    <!-- ES6 Object Literals -->
    <h2>ES6 Object Literals</h2>
    <p>• Applications in javascript are getting more complex with time and use lots of objects, which makes sense as
        almost everything in javascript are some types of objects.</p>
    <p>• With more objects, comes necessity to use them more efficiently and ES6 focuses heavily on improving them.</p>
    <p>• JavaScript has different types of objects used in standard as well as in the execution environment added by the
        browsers or Nodejs.</p>
    <p>• The succinct syntax of object literals for creating objects in javascript has made it so popular that JSON
        adopted the same syntax. ES6 make object literals more powerful and more succinct by extending the syntax.</p>

    <!-- Deconstructing variables into keys and values -->
    • <strong>Deconstructing variables into keys and values</strong>
    <p>-- <u>Before ES6</u> :
        <br> Creating an object literal in javascript.
        <br><br> var name = 'Prashant Yadav';
        <br> var age = 23;
        <br> var nationality = 'Indian';
        <br> var designation = 'Software Engineer';
        <br><br> var user = {
        <br> name : name,
        <br> age : age,
        <br> nationality : nationality,
        <br> designation : designation
        <br> }
        <br><br> console.log(user);
        <br> // {name : 'Prashant Yadav', age : 23, nationality : 'Indian', designation : 'Software Engineer'}
    </p>
    <p>-- <u>After ES6</u> :
        <br> Creating an object literal in ES6.
        <br><br> var name = 'Prashant Yadav';
        <br> var age = 23;
        <br> var nationality = 'Indian';
        <br> var designation = 'Software Engineer';
        <br><br> var user = {
        <br> name,
        <br> age,
        <br> nationality,
        <br> designation
        <br> }
        <br><br> console.log(user);
        <br> // {name : 'Prashant Yadav', age : 23, nationality : 'Indian', designation : 'Software Engineer'}
    </p>
    <p>-- If variable name is same as the property name then we can skip assigning the value to the property and use the
        above syntax to declare objects.</p>

    <!-- Declaring functions inside objects -->
    • <strong>Declaring functions inside objects</strong>
    <p>-- <u>Before ES6</u> :
        <br><br> var name = 'Prashant Yadav';
        <br> var age = 23;
        <br> var nationality = 'Indian';
        <br> var designation = 'Software Engineer';
        <br><br> var user = {
        <br> name : name,
        <br> age : age,
        <br> nationality : nationality,
        <br> designation : designation,
        <br> detail : function () {
        <br> return this.name + ' is an ' + this.nationality + ' working as ' + this.designation;
        <br> }}
        <br><br>console.log(user.detail());
        <br> // Prashant Yadav is an Indian working as Software Engineer
    </p>
    <p>-- <u>After ES6</u> :
        <br><br> var name = 'Prashant Yadav';
        <br> var age = 23;
        <br> var nationality = 'Indian';
        <br> var designation = 'Software Engineer';
        <br><br> var user = {
        <br> name,
        <br> age,
        <br> nationality,
        <br> designation
        <br> detail() {
        <br> return this.name + ' is an ' + this.nationality + ' working as ' + this.designation;
        <br> }}
        <br><br> console.log(user);
        <br> // {name : 'Prashant Yadav', age : 23, nationality : 'Indian', designation : 'Software Engineer'}
    </p>
    <p>-- We no longer need to declare function keyword, we can declare the function directly with above syntax.</p>

    <!-- We can also declare the => fat arrow function -->
    • <strong>We can also declare the => fat arrow function</strong>
    <p>const math = {
        <br> add : (a, b) => a + b,
        <br> mul : (a, b) => a * b,
        <br> sub : (a, b) => a-b,
        <br> div : (a, b) => a / b,
        <br> }
        <br><br> console.log(math.add(1, 1)); // 2
        <br> console.log(math.mul(1, 1)); // 1
        <br> console.log(math.sub(1, 1)); // 0
        <br> console.log(math.div(1, 1)); // 1
    </p>

    <!-- Dynamically define properties of an object -->
    • <strong>Dynamically define properties of an object</strong>
    <p>-- <u>Before ES6</u> :
        <br><br> To dynamically define properties of the object in ES5 or earlier we used to first create the object and
        then modify it.
        <br><br> var name = 'name';
        <br> // create empty object
        <br><br> var user = {}
        <br> // update the object
        <br><br> var [name] = 'Prashant Yadav';
        <br><br> console.log(user.name);
        <br> // Prashant Yadav
    </p>
    <p>-- <u>After ES6</u> :
        <br><br> With ES6 we can do both the things same time. Computed property names are part of the object literal
        syntax.
        <br><br> var name = 'first';
        <br><br> var suffix = 'name';
        <br> // create empty object and assigning the value
        <br><br> var user = {
        <br> [name] : 'Prashant',
        <br> ['last ' + suffix] : 'Yadav'
        <br> }
        <br><br> console.log(user.first + ' ' + user['last name']);
        <br> // Prashant Yadav
    </p>

    <!-- Declaring duplicate properties -->
    • <strong>Declaring duplicate properties</strong>
    <p>-- <u>Before ES6</u> :
        <br><br> In ES5 and earlier declaring duplicate property names inside object literals in strict mode would throw
        error.
        <br><br>'use strict';
        <br> var user = {
        <br> name : 'prashant',
        <br> name : 'golu'
        <br> }
        <br><br> // syntax error
    </p>
    <p>-- <u>After ES6</u> :
        <br><br> In ES6 we can declare duplicate property names inside object literals in strict as well as nonstrict
        mode. It will just overwrite the existing value.
        <br><br>'use strict';
        <br> var user = {
        <br> name : 'prashant',
        <br> name : 'golu'
        <br> }
        <br><br> console.log(user.name);
        <br> // golu
    </p>
    <hr>

    <!-- JavaScript Set -->
    <h2>JavaScript Set</h2>
    <p>• Before ES6 there was only one data-structure, Array which we could have used for numeric operations and for
        other non-numeric operations we had to use Objects.</p>
    <p>• Arrays came with extra methods which we could use to create stack and queue.</p>
    <p>• With the introduction of javascript Set and Map, we now have some extra data-structures in javascript's
        library.</p>
    <p>• Sets are the unique collection of values of any type, which also includes NaN and undefined.</p>

    <!-- Before ES6 -->
    <p>-- <u>Before ES6</u> :
        <br><br> Before sets introduction in ES6 there was workaround which developers used to have to create sets but
        there was limitation to that workaround. Let us see that first to exactly know why there was need for it.
        <br><br> var set = {};
        <br> if (!set.foo) {
        <br> set.foo = true;
        <br> }
    </p>
    <p>-- We have created an emoty object and assigned true to the properties so that we can check if that value is
        present.</p>
    <p>-- This works well in the simple scenarios but when we have to use more complex situations we run into the
        limitations of the object properties.</p>
    <p>var set = {};
        <br> var key = {};
        <br> set[25] = 'prashant';
        <br> set[key] = 5;
        <br><br> console.log(set['25']); // prashant
        </br> console.log(set[key]); // 5
    </p>
    <p>-- Here the object internally converts the numeric 25 and key to string '25' because object parameters must be
        string, Thus we cannot use both of them simultaneously.</p>

    <!-- After ES6 -->
    <p>-- <u>After ES6</u> :
        <br><br> With introduction of Set and WeakSet in ES6 we don't have to worry about the workaround limitations.
        <br>let set = new Set([!iterable]);
        <br> if an iterable object like Array is passed then all its items will be added to the set.
        <br><br> let set = new Set();
        <br> set.add(25);
        <br> set.add('25');
        <br><br> let set2 = new Set([1, 2, 3, 4, 5, 6, 7, 8]);
        <br> let set3 = new Set('Prashant');
        <br><br> console.log(set.size); // 2
        <br> console.log(set2.size); // 2
        <br> console.log(set3.size); // 7 ['P', 'r', 'a', 's', 'h', 'n', 't'];
    </p>
    <p>-- Sets do not convert the values while checking (Except for +0 and -0).</p>
    <p>let set = new Set();
        <br> let key = {};
        <br> let key2 = {};
        <br> set.add(key);
        <br> set.add(key2);
        <br><br> console.log(set.size) // 2
    </p>

    <!-- Sets Properties -->
    • <strong>Sets Properties</strong>
    <p>-- Set.prototype.constructor <br>
        -- Set.prototype.size
    </p>

    <!-- Sets Methods -->
    • <strong>Sets Methods</strong>
    <p>-- Set.prototype.add(item)
        <br> -- Set.prototype.clear()
        <br> -- Set.prototype.delete(item)
        <br> -- Set.prototype.entries()
        <br> -- Set.prototype.foreach(callback, thisArg)
        <br> -- Set.prototype.has(item)
        <br> -- Set.prototype[@@iterator]()
        <br> -- Set.prototype.keys()
        <br> -- Set.prototype.values()
    </p>

    <!-- Iterating with javascript Set -->
    • <strong>Iterating with javascript Set</strong>
    <p>-- <u>Simple Iteration</u>
        <br><br> let set = new Set();
        <br> set.add(1);
        <br> set.add(2);
        <br> set.add(3);
        <br> set.add(4);
        <br><br> // foreach loop
        <br> set.forEach((e) => {console.log(e);});
        <br> // 1
        <br> // 2
        <br> // 3
        <br> // 4
        <br><br> for of loop
        <br> for (let item of set) {console.log(item);}
        <br> // 1
        <br> // 2
        <br> // 3
        <br> // 4
    </p>

    <!-- Iterating objects of Set -->
    <p>-- <u>Iterating objects of Set</u>
        <br><br> let set = new Set();
        <br> set.add(1);
        <br> set.add('prashant');
        <br> set.add({a: 1, b: 2, c:3, d:4});
        <br><br> for (let item of set.keys()) {
        <br> console.log(item);
        <br> }
        <br> // 1
        <br> // prashant
        <br> // {a: 1, b: 2, c: 3, d: 4}
        <br><br> for (let item of set.values()) {
        <br> console.log(item);
        <br> }
        <br> // 1
        <br> // prashant
        <br> // {a:1, b:2, c:3, d:4}
        <br><br> for (let [key, value] of set.entries()) {
        <br> console.log(key, value);
        <br> }
        <br> // 1 1
        <br> // prashant prashant
        <br> // {a:1, b:2, c:3, d:4} {a:1, b:2, c:3, d:4}
        <br><br> let set = new Set();
        <br> set.add(1);
        <br> set.add('prashant');
        <br> set.add({a:1, b:2, c:3, d:4});
        <br><br> // using `.next()`
        <br>const iterator = set.values();
        <br><br> console.log(iterator.next().value);
        <br> // 1
        <br><br> console.log(iterator.next().value);
        <br> // prashant
        <br><br> console.log(iterator.next().value);
        <br> // {a:1, b:2, c:3, d:4}
    </p>
    <hr>

    <!-- WeakSets -->
    <h2>WeakSets</h2>
    <p>• A WeakSet is same as the Set except it can only store objects.</p>
    <p>let user = {name: 'Prashant Yadav', age: 23};
        <br>const users = new WeakSet(user);
    </p>
    <hr>

    <!-- Difference between Sets and WeakSets -->
    <h2>Difference between Sets and WeakSets</h2>
    <p>• WeakSets can only store objects unlike the Sets.</p>
    <p>• The add() method throws error when non-object item is passed to the WeakSet.</p>
    <p>• The has() and delete() method returns false for non-object.</p>
    <p>• WeakSets are not Iterable.</p>
    <p>• They do not have size and foreach as well.</p>
    <p> let user = {name: 'Prashant Yadav', age: 23};
        <br> let user2 = {name: 'Prashant Yadav', age: 23};
        <br> let user3 = {name: 'Prashant Yadav', age: 23};
        <br><br> const users = new WeakSet();
        <br> users.add(user);
        <br> users.add(user2);
        <br> users.add(user3);
        <br><br> console.log(users.has(user2)); // true
        <br><br> users.delete(user2);
        <br><br> console.log(users.has(user2)); // false
    </p>
    <p>• The WeakSet cleans itself once the object is deleted or if there is no reference to the object.</p>
    <p> console.log(users);
        <br> user3 = null;
        <br> console.log(users);
        <br> // WeakSet {{...}, {...}}
        <br><br> // Wait for few seconds
        <br> console.log(users);
        <br> // WeakSet {{...}}
        <br> // it automatically garbage collect the object.
    </p>
    <hr>

    <script src="script.js" async defer></script>
</body>

</html>